<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CAMARA OBR PRO v5.4.8 (ANTI-FLICKER)</title> 
    
    <link rel="icon" type="image/png" href="obr-logo.png">
    <link rel="apple-touch-icon" href="obr-logo.png">
    <meta name="theme-color" content="#000000">
    
    <!-- PWA MANIFEST -->
    <link rel="manifest" href='data:application/manifest+json,{"name":"OBR CAM PRO","short_name":"OBR CAM","start_url":".","display":"standalone","background_color":"#000000","theme_color":"#000000","icons":[{"src":"obr-logo.png","sizes":"192x192","type":"image/png"},{"src":"obr-logo.png","sizes":"512x512","type":"image/png"}]}'>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LIBRER√çAS: Carga Local Prioritaria -->
    <script src="js/tf.min.js"></script>
    <script src="js/pose-detection.min.js"></script>
    <script src="js/face_mesh.js"></script>
    <script src="js/selfie_segmentation.js"></script> 
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <!-- Fallbacks CDN -->
    <script>
        if(!window.tf) document.write('<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"><\/script>');
        if(!window.poseDetection) document.write('<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3"><\/script>');
        if(!window.FaceMesh) document.write('<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"><\/script>');
        if(!window.SelfieSegmentation) document.write('<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"><\/script>');
    </script>
    
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        * { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; box-sizing: border-box; outline: none; touch-action: none; }
        :root { --hud-primary: #ff3333; }
        body { background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; width: 100vw; height: 100vh; margin: 0; padding: 0; }
        
        #main-view-area { position: absolute; inset: 0; background: #000; overflow: hidden; transition: filter 0.3s ease; }
        #zoom-container { position: absolute; inset: 0; width: 100%; height: 100%; transform-origin: center center; transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); will-change: transform; }
        
        #shared-video-element { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; opacity: 0; pointer-events: none; }
        #sls-canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: 2; pointer-events: none; }
        
        #heatmap-buffer, #lidar-buffer { display: none; }

        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 20; }
        .interactive { pointer-events: auto; cursor: pointer; }
        
        #orientation-lock { position: fixed; inset: 0; z-index: 9999; background: #000; display: none; flex-direction: column; align-items: center; justify-content: center; }
        @media (orientation: portrait) { #orientation-lock { display: flex; } #ui-layer { display: none; } }

        /* OPTIMIZACI√ìN FILTROS GPU */
        body.filter-night-vision #main-view-area { filter: contrast(1.2) brightness(1.2) sepia(100%) hue-rotate(90deg); }
        body.filter-thermal #main-view-area { filter: contrast(1.4) brightness(0.7) invert(1) grayscale(1); }
        body.filter-urbex #main-view-area { filter: contrast(1.3) saturate(1.8) sepia(0.8) hue-rotate(-15deg); }
        body.filter-pareidolia #main-view-area { filter: contrast(1.1) brightness(0.8) grayscale(0.8); }

        .hud-burn-hidden { display: none !important; }

        #tally-border { position: absolute; inset: 0; border: 0px solid transparent; transition: all 0.2s ease-out; z-index: 50; pointer-events: none; }
        #tally-border.preview { border: 4px solid #00ff00; opacity: 0.8; }
        #tally-border.online { border: 6px solid #ff0000; box-shadow: inset 0 0 20px rgba(255,0,0,0.5), 0 0 15px rgba(255,0,0,0.5); opacity: 1; }

        #ai-scan-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 55; display: none; overflow: hidden; }
        
        .scan-box { 
            position: absolute; 
            border: 2px solid rgba(255, 0, 0, 0.9); 
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6), inset 0 0 10px rgba(255, 0, 0, 0.3); 
            background: rgba(255, 0, 0, 0.1); 
            opacity: 0; 
            animation: targetScan 0.6s ease-out forwards; 
        }
        @keyframes targetScan { 
            0% { transform: scale(1.3); opacity: 0; border-color: white; } 
            10% { opacity: 1; border-color: red; } 
            80% { transform: scale(1); opacity: 1; } 
            100% { transform: scale(0.8); opacity: 0; } 
        }

        #toast-container { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 8px; z-index: 200; pointer-events: none; width: 80%; align-items: center; }
        .toast { background: rgba(0, 30, 0, 0.9); border: 1px solid #00ff00; color: #00ff00; padding: 10px 20px; border-radius: 4px; font-family: 'Share Tech Mono'; font-size: 14px; text-shadow: 0 0 5px #00ff00; box-shadow: 0 4px 15px rgba(0,0,0,0.8); animation: slideDown 0.3s ease-out; pointer-events: auto; text-align: center; }
        .toast.error { border-color: red; color: red; background: rgba(30, 0, 0, 0.9); text-shadow: 0 0 5px red; }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

        .menu-container { position: absolute; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 15px; z-index: 100; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
        .menu-container.visible { opacity: 1; pointer-events: auto; }
        .menu-container.left-side { left: 20px; }
        .menu-container.right-side { right: 20px; }
        .menu-btn { width: 50px; height: 50px; border: 2px solid var(--hud-primary); border-radius: 50%; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; color: var(--hud-primary); font-size: 1.2rem; backdrop-filter: blur(4px); transition: all 0.2s; cursor: pointer; pointer-events: auto; }
        .menu-btn:active { transform: scale(0.9); }
        .menu-btn.active-state { background: white; border-color: white; color: black; box-shadow: 0 0 20px white; }
        .menu-label { font-size: 0.55rem; color: white; text-align: center; margin-top: 4px; font-family: 'Share Tech Mono'; background: rgba(0,0,0,0.6); border-radius: 4px; }

        #telemetry-container { position: absolute; bottom: 10px; right: 10px; display: flex; flex-direction: column; align-items: flex-end; gap: 2px; pointer-events: none; z-index: 150; }
        .stat-row { font-family: 'Share Tech Mono', monospace; font-size: 10px; color: rgba(0, 255, 0, 0.7); text-shadow: 1px 1px 0px black; background: rgba(0,0,0,0.3); padding: 1px 4px; border-radius: 2px; display: flex; align-items: center; gap: 6px; }
        .signal-bars { display: flex; align-items: flex-end; gap: 2px; height: 12px; width: 16px; }
        .bar { width: 4px; background: #333; border-radius: 1px; transition: background 0.3s; }
        .bar:nth-child(1) { height: 33%; } .bar:nth-child(2) { height: 66%; } .bar:nth-child(3) { height: 100%; }
        .signal-level-0 .bar { background: #333; }
        .signal-level-1 .bar:nth-child(1) { background: #ff3333; }
        .signal-level-2 .bar:nth-child(1), .signal-level-2 .bar:nth-child(2) { background: #ffff00; }
        .signal-level-3 .bar { background: #00ff00; }

        #loading { position: fixed; inset: 0; z-index: 200; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .modal-bg { position: fixed; inset: 0; z-index: 300; background: rgba(0,0,0,0.95); display: none; align-items: center; justify-content: center; }
        .modal-bg.active { display: flex; }
        #progress-bar { height: 100%; width: 0%; background: var(--hud-primary); transition: width 0.3s; }
        
        #zoom-target-indicator { position: absolute; width: 60px; height: 60px; border: 2px solid #00ff00; border-radius: 50%; transform: translate(-50%, -50%) scale(0.5); opacity: 0; pointer-events: none; z-index: 80; transition: transform 0.3s, opacity 0.3s; }
        #zoom-target-indicator.active { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    </style>
</head>
<body>

    <div id="orientation-lock">
        <i class="fas fa-mobile-alt text-4xl mb-4 rotate-90 text-red-500"></i>
        <h2 class="text-xl font-bold font-orbitron tracking-widest text-red-500">GIRAR DISPOSITIVO</h2>
    </div>

    <div id="main-view-area">
        <div id="zoom-container">
            <video id="shared-video-element" autoplay playsinline muted></video>
            <canvas id="sls-canvas"></canvas>
        </div>
        <div id="ai-scan-overlay"></div>
    </div>
    <canvas id="heatmap-buffer"></canvas>
    <canvas id="lidar-buffer"></canvas>
    
    <div id="touch-surface" class="absolute inset-0 z-10 interactive"></div>
    <div id="zoom-target-indicator"></div>

    <div id="ui-layer">
        <div id="hud-layer" class="hud-burn-hidden">
            <img src="obr-logo.png" id="hud-logo" alt="OBR">
            <div id="hud-text-container">
                <div id="hud-title">EXPLORACIONES OBR</div>
                <div id="hud-time">--/--/-- - --:--:--</div>
            </div>
        </div>

        <div id="toast-container"></div>
        <div id="tally-border" class="preview"></div>
        <div id="sls-pip" class="absolute top-4 left-1/2 -translate-x-1/2 text-purple-500 font-mono text-xs hidden bg-black/50 px-2 rounded border border-purple-500 hud-burn-hidden">‚óè SLS ACTIVO</div>
        
        <div id="link-status" class="absolute bottom-4 left-4 text-[10px] font-mono text-gray-400 bg-black/60 px-2 py-1 rounded border border-gray-800 flex items-center gap-2">
            <div id="status-dot" class="w-2 h-2 rounded-full bg-neutral-600"></div>
            <span id="status-text">LOCAL</span>
        </div>

        <div class="absolute top-4 right-4 interactive text-gray-500 p-2 bg-black/30 rounded-full hover:text-white" onclick="openSettings()"><i class="fas fa-cog text-xl"></i></div>
        
        <div id="telemetry-container">
            <div class="stat-row"><span id="meta-res">INIT...</span><i class="fas fa-expand text-[8px]"></i></div>
            <div class="stat-row"><span id="meta-fps">-- FPS</span><div class="signal-bars signal-level-0" id="signal-ui"><div class="bar"></div><div class="bar"></div><div class="bar"></div></div></div>
        </div>

        <div id="menu-left" class="menu-container left-side">
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('night', this)" id="btn-night"><i class="fas fa-moon"></i></div><div class="menu-label">NOCT</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('thermal', this)" id="btn-thermal"><i class="fas fa-fire"></i></div><div class="menu-label">NEG</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('urbex', this)" id="btn-urbex"><i class="fas fa-city"></i></div><div class="menu-label">URBEX</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('sls', this)" id="btn-sls"><i class="fas fa-ghost"></i></div><div class="menu-label">SLS</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('lidar', this)" id="btn-heatmap"><i class="fas fa-fingerprint"></i></div><div class="menu-label">LIDAR</div></div>
        </div>
        <div id="menu-right" class="menu-container right-side">
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="togglePareidolia(this)" id="btn-ia"><i class="fas fa-eye"></i></div><div class="menu-label">VISION</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="openConnect()"><i class="fas fa-link"></i></div><div class="menu-label">LINK</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="resetZoom(this)"><i class="fas fa-compress"></i></div><div class="menu-label">RESET</div></div>
        </div>
    </div>

    <div id="loading">
        <img src="obr-logo.png" class="w-24 h-24 object-contain mb-4 animate-pulse drop-shadow-[0_0_20px_rgba(220,38,38,0.5)]">
        <h1 class="text-3xl text-red-600 font-bold mb-1 tracking-widest font-orbitron">OBR CAM</h1>
        <p class="text-xs font-mono text-gray-500 mb-8">LIDAR v5.4.8 (ANTI-FLICKER)</p>
        <div class="w-64 h-1 bg-gray-800 rounded overflow-hidden"><div id="progress-bar"></div></div>
        <div id="progress-text" class="mt-2 text-xs font-mono text-red-500">CARGANDO...</div>
        <button class="mt-8 px-8 py-3 bg-red-900/20 border border-red-600 text-red-500 font-bold font-orbitron rounded hover:bg-red-900/50 transition load-btn" onclick="initApp()">INICIAR C√ÅMARA</button>
    </div>

    <div id="connect-modal" class="modal-bg">
        <div class="bg-neutral-900 border border-cyan-500 p-8 rounded-lg w-80 text-center shadow-[0_0_30px_rgba(0,255,255,0.1)]">
            <h3 class="text-cyan-400 mb-4 text-xl tracking-widest font-bold">CONECTAR A ESTUDIO</h3>
            <input type="text" id="stream-name" placeholder="NOMBRE (EJ: cam1)" class="w-full bg-black border border-gray-700 text-white p-3 text-center uppercase mb-4 text-lg outline-none focus:border-cyan-400 rounded" value="cam1">
            <button onclick="startHybridTransmission()" class="w-full bg-cyan-900 text-white font-bold py-3 hover:bg-cyan-700 mb-3 rounded font-orbitron">ENLAZAR</button>
            <button onclick="document.getElementById('connect-modal').classList.remove('active')" class="text-gray-500 text-xs hover:text-white">CANCELAR</button>
        </div>
    </div>

    <div id="settings-modal" class="modal-bg">
        <div class="relative bg-neutral-900 border border-red-900 p-6 rounded w-[480px] max-w-[95%] shadow-[0_0_30px_rgba(255,0,0,0.1)]">
            <button onclick="document.getElementById('settings-modal').classList.remove('active')" class="absolute top-3 right-3 text-gray-600 hover:text-red-500 transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>
            <h2 class="text-red-500 font-orbitron mb-4 font-bold text-center uppercase tracking-widest text-lg">CONFIGURACI√ìN SISTEMA</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-black/50 p-3 rounded border border-gray-800">
                    <h3 className="text-xs font-bold text-gray-400 mb-2 border-b border-gray-700 pb-1">RED ESTUDIO</h3>
                    <label class="text-[9px] text-gray-500 font-mono mb-1 block uppercase">DOCK ID / IP</label>
                    <input type="text" id="mtx-host" placeholder="EJ: 192.168.1.50" class="w-full bg-black border border-gray-700 p-2 text-white text-xs rounded font-mono outline-none focus:border-red-500 text-center mb-2">
                    <p class="text-[8px] text-gray-600 font-mono uppercase text-center leading-tight">IP SE CONVIERTE A ID AUTO</p>
                </div>
                <div class="bg-black/50 p-3 rounded border border-gray-800">
                    <h3 className="text-xs font-bold text-gray-400 mb-2 border-b border-gray-700 pb-1">IA ANALYZER</h3>
                    <label class="text-[9px] text-gray-500 font-mono mb-1 block">API KEY</label>
                    <div class="relative w-full mb-2">
                        <input type="password" id="api-key-internal" placeholder="GEMINI KEY" class="w-full bg-black border border-gray-700 p-2 pr-10 text-white text-xs rounded outline-none focus:border-red-500">
                        <button onclick="window.open('https://aistudio.google.com/api-keys', '_blank')" class="absolute right-2 top-1/2 -translate-y-1/2 text-base hover:scale-110 transition-transform leading-none" title="Crear API Key">
                            üì≤
                        </button>
                    </div>
                    <button id="btn-validate-api" onclick="validateAndSaveKey()" class="w-full border border-green-800 text-green-500 hover:bg-green-900/30 py-1 rounded text-[10px] font-bold">VALIDAR KEY</button>
                    <div id="api-status-msg" class="text-[9px] font-mono mt-1 text-center text-yellow-500 h-3"></div>
                </div>
            </div>
            <div class="h-px bg-gray-800 w-full mb-4"></div>
            <button onclick="saveSettings()" class="w-full bg-red-900/20 border border-red-600 text-red-500 hover:bg-red-900/50 hover:text-white py-3 rounded text-sm font-bold uppercase tracking-widest transition-colors font-orbitron">GUARDAR Y CERRAR</button>
        </div>
    </div>

<script>
    const AI_SENSITIVITY = 0.2; 
    const state = { 
        apiKey: localStorage.getItem("obr_gemini_key") || "", 
        aiModel: localStorage.getItem("obr_ai_model") || "gemini-2.5-flash-preview-09-2025", 
        studioId: localStorage.getItem("obr_studio_id") || "",
        filter: 'normal', 
        isSLS: false, 
        isLidar: false, 
        isPareidolia: false, 
        zoom: 1,
        isStreaming: false
    };
    
    const PEER_CONFIG = {
        config: {
            iceServers: [
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        }
    };
    
    let GEMINI_API_KEY = state.apiKey;
    let CURRENT_AI_MODEL = state.aiModel;
    let isAIProcessing = false;
    let isPareidoliaActive = false;
    let pareidoliaInterval = null;
    let scanInterval = null;
    let lastPareidoliaCall = 0; 
    let imageCollapseTimeout = null;

    let currentAiText = "";
    let currentAiImage = null; 
    let aiTextTimer = null;
    let radarAngle = 0; 
    let canvasScanBoxes = []; 

    let aiScannerState = 0; 
    let aiScannerTimer = 0;
    
    // --- SCHEDULER DE IA (Throttle) ---
    let lastAI = 0;
    const AI_INTERVAL = 350; // ~2.8 FPS
    
    function aiScheduler(time) {
        if (time - lastAI > AI_INTERVAL) {
            aiLoop();
            lastAI = time;
        }
        requestAnimationFrame(aiScheduler);
    }

    // --- ESTADO TALLY GLOBAL ---
    let tallyState = 'idle'; // 'idle', 'preview', 'program'

    const animState = {
        hudScale: 1.0,
        hudTarget: 1.0,
        aiScale: 0.0,
        aiTarget: 0.0
    };

    const el = { video: document.getElementById('shared-video-element'), canvas: document.getElementById('sls-canvas'), heatCanvas: document.getElementById('heatmap-buffer'), lidarCanvas: document.getElementById('lidar-buffer'), zoom: document.getElementById('zoom-container'), statusText: document.getElementById('status-text'), statusDot: document.getElementById('status-dot') };

    // OPTIMIZACI√ìN CANVAS: Desincronizado y sin lectura frecuente
    const ctx = el.canvas.getContext('2d', { alpha: true, desynchronized: true, willReadFrequently: false });
    const lidarCtx = el.lidarCanvas.getContext('2d', { alpha: true });
    
    // OPTIMIZACI√ìN IA: Resoluci√≥n de entrada 224x224 (MoveNet Standard)
    const aiCanvas = document.createElement('canvas'); 
    aiCanvas.width = 224; 
    aiCanvas.height = 224;
    const aiCtx = aiCanvas.getContext('2d', { willReadFrequently: true });

    let aiDetector = null, faceMesh = null, segmenter = null, poses = [], faces = [], lidarMask = null;
    let lidarBusy = false; 
    let lastLidarMask = null;
    
    // VARIABLE INTERPOLACI√ìN LIDAR Y CONFIDENCE GATE
    let lidarBlend = 0;
    let lidarHoldFrames = 0;
    
    let videoStream, peerCommand = null, peerVideoSender = null, conn = null;
    let frameCount = 0, lastTime = performance.now(), currentFps = 0;

    let logoImg = new Image(); logoImg.src = 'obr-logo.png';

    window.onload = () => { 
        document.getElementById('api-key-internal').value = state.apiKey; 
        document.getElementById('mtx-host').value = state.studioId; 
    };

    async function initApp() {
        document.querySelector('.load-btn').style.display = 'none';
        try {
            updateProgress(10, "INICIANDO SENSOR...");
            // OPTIMIZACI√ìN C√ÅMARA: Alta fluidez, resoluci√≥n ideal 1080p
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: { echoCancellation: true }, 
                video: { 
                    facingMode: 'environment', 
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: 30, max: 60 }
                } 
            });
            videoStream = stream; el.video.srcObject = stream; el.video.play();
        } catch(e) {
            alert("Error Cr√≠tico C√°mara: " + e.message);
            return; 
        }
        updateProgress(100, "VIDEO OK");
        document.getElementById('loading').style.display = 'none';
        resize(); window.addEventListener('resize', resize);
        requestAnimationFrame(renderLoop);
        setInterval(telemetryLoop, 1000);
        showToast("Cargando Motores IA...", false);
        
        // HEARTBEAT LIDAR DESACOPLADO (3 FPS ESTABLES)
        setInterval(() => {
            if (state.isLidar && segmenter && !lidarBusy) {
                lidarBusy = true;
                segmenter.send({ image: el.video })
                  .finally(() => lidarBusy = false);
            }
        }, 333); // AUMENTADO A 333ms PARA EVITAR FLICKER

        setTimeout(async () => {
            try {
                // OPTIMIZACI√ìN: Carga inicial de librer√≠as para cach√© (Precarga)
                if(window.tf) { try { await tf.setBackend('webgl'); } catch(e) { await tf.setBackend('cpu'); } }
                if(window.poseDetection) { try { aiDetector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, { modelType: poseDetection.movenet.modelType.MULTIPOSE_LIGHTNING }); } catch(e) {} }
                if(window.FaceMesh) { try { faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`}); faceMesh.setOptions({ maxNumFaces: 3, minDetectionConfidence: AI_SENSITIVITY }); faceMesh.onResults(res => { faces = res.multiFaceLandmarks || []; }); await faceMesh.initialize(); } catch(e) {} }
                
                // OPTIMIZACI√ìN SEGMENTER: ANTI-FLICKER MODE
                if(window.SelfieSegmentation) { 
                    try { 
                        const selfieSegmentation = new SelfieSegmentation({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`}); 
                        // CRITICO: smoothSegmentation: false elimina recalibraci√≥n
                        selfieSegmentation.setOptions({ modelSelection: 1, smoothSegmentation: false }); 
                        selfieSegmentation.onResults(res => { 
                            // MEJORA PRO: CONFIDENCE GATE + NO BLEND RESET
                            if(res && res.segmentationMask) { 
                                lidarMask = res.segmentationMask; 
                                lastLidarMask = res.segmentationMask; 
                                lidarHoldFrames = 5; // Reset hold
                                // lidarBlend = 0; // ELIMINADO para evitar flashes
                            } else if (lidarHoldFrames > 0) {
                                lidarHoldFrames--;
                                lidarMask = lastLidarMask; // Usar anterior si hay fallo
                            }
                            lidarBusy = false; 
                        }); 
                        segmenter = selfieSegmentation; 
                    } catch(e) {} 
                }
                showToast("SISTEMAS IA LISTOS", false);
                // OPTIMIZACI√ìN: Inicio de loop IA controlado por Scheduler
                requestAnimationFrame(aiScheduler);
            } catch(globalErr) { console.error("Error Global IA:", globalErr); showToast("IA: Carga Parcial (Cam OK)", true); }
        }, 500); 
    }

    function onLidarResults(results) { if(results && results.segmentationMask) lidarMask = results.segmentationMask; }
    
    // MEJORA VISUAL: INTERPOLACI√ìN DE M√ÅSCARA
    function drawLidarEffect(c, width, height) {
        const mask = lidarMask || lastLidarMask;
        if (!mask) return;

        // VELOCIDAD DE MEZCLA AJUSTADA A 0.08
        lidarBlend = Math.min(lidarBlend + 0.08, 1); 

        lidarCtx.clearRect(0, 0, width, height);
        lidarCtx.globalAlpha = lidarBlend;
        lidarCtx.drawImage(mask, 0, 0, width, height);
        lidarCtx.globalAlpha = 1;

        lidarCtx.globalCompositeOperation = 'source-in';
        const grad = lidarCtx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, 'rgba(255, 0, 0, 0.9)'); 
        grad.addColorStop(0.5, 'rgba(255, 255, 0, 0.8)'); 
        grad.addColorStop(1, 'rgba(0, 0, 255, 0.8)');
        lidarCtx.fillStyle = grad; 
        lidarCtx.fillRect(0, 0, width, height);
        lidarCtx.globalCompositeOperation = 'source-over';
        
        c.globalCompositeOperation = 'screen'; 
        c.drawImage(el.lidarCanvas, 0, 0, width, height); 
        c.globalCompositeOperation = 'source-over';
    }

    function resize() { el.canvas.width = window.innerWidth; el.canvas.height = window.innerHeight; el.lidarCanvas.width = window.innerWidth; el.lidarCanvas.height = window.innerHeight; }
    function updateProgress(p, t) { document.getElementById('progress-bar').style.width = p + '%'; document.getElementById('progress-text').innerText = t; }

    function drawBurnInHUD(ctx, width, height, scale) {
        if(scale <= 0.01) return;
        ctx.save();
        const centerX = 20 + 80; const centerY = 20 + 20; 
        ctx.translate(centerX, centerY); ctx.scale(scale, scale); ctx.translate(-centerX, -centerY);
        ctx.shadowColor = "black"; ctx.shadowBlur = 4;
        if(logoImg.complete) ctx.drawImage(logoImg, 20, 20, 40, 40);
        ctx.fillStyle = "white"; ctx.font = "bold 16px 'Orbitron', sans-serif";
        ctx.fillText("EXPLORACIONES OBR", 70, 40);
        const now = new Date();
        ctx.fillStyle = "#ff3333"; ctx.font = "12px 'Share Tech Mono', monospace";
        ctx.fillText(now.toLocaleDateString() + " - " + now.toLocaleTimeString(), 70, 58);
        if(state.isSLS) {
            const bx = width/2 - 40;
            ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(bx, 20, 80, 20);
            ctx.strokeStyle = "#d946ef"; ctx.lineWidth = 1; ctx.strokeRect(bx, 20, 80, 20);
            ctx.fillStyle = "#d946ef"; ctx.font = "10px monospace"; ctx.fillText("‚óè SLS ACTIVO", bx + 5, 33);
        }
        ctx.restore();
    }

    function drawGlitchText(c, text, x, y, size = 12) {
        const glitchOffset = Math.random() * 4 - 2;
        c.font = `bold ${size}px 'Share Tech Mono'`;
        c.fillStyle = "rgba(255, 0, 0, 0.7)"; c.fillText(text, x + glitchOffset, y);
        c.fillStyle = "rgba(0, 255, 255, 0.7)"; c.fillText(text, x - glitchOffset, y);
        c.fillStyle = "#ffffff"; c.fillText(text, x, y);
    }
    
    function drawCanvasScanBoxes(c, w, h) {
        const now = Date.now();
        canvasScanBoxes = canvasScanBoxes.filter(box => now - box.startTime < 800);
        canvasScanBoxes.forEach(box => {
            const age = now - box.startTime; const alpha = 1 - (age / 800); const scale = 1.3 - (age / 800) * 0.5;
            c.save(); c.translate(box.x + box.size/2, box.y + box.size/2); c.scale(scale, scale); c.translate(-(box.x + box.size/2), -(box.y + box.size/2));
            c.strokeStyle = `rgba(255, 0, 0, ${alpha * 0.9})`; c.lineWidth = 2; c.strokeRect(box.x, box.y, box.size, box.size);
            c.shadowBlur = 10; c.shadowColor = `rgba(255, 0, 0, ${alpha * 0.6})`; c.strokeRect(box.x, box.y, box.size, box.size);
            c.restore();
        });
    }

    function drawAIBurnIn(c, w, h, scale) {
        if(scale <= 0.01) return;
        c.save();
        const bx = 20, by = 20; const panelW = 220; 
        let displayTxt = currentAiText;
        let isScanning = !currentAiImage; 
        
        if (isScanning && !displayTxt) {
             aiScannerTimer++;
             if(aiScannerTimer > 150) { aiScannerState = (aiScannerState + 1) % 3; aiScannerTimer = 0; }
             if(aiScannerState === 0) displayTxt = "Analizando Entorno...";
             else if(aiScannerState === 1) displayTxt = `raw data: 0x${Math.floor(Math.random()*16777215).toString(16)}`;
             else if(aiScannerState === 2) displayTxt = "sensores:\n  lidar: on\n  temp: 14c\n  prox: 98%";
        }
        
        let borderColor = isScanning ? "#ff0000" : "#ff3333";
        let bgColor = isScanning ? "rgba(0,0,0,0)" : "rgba(10, 0, 0, 0.90)"; 
        let imgH = 0;
        if (isScanning) { imgH = 150; } else if(currentAiImage && currentAiImage.complete && currentAiImage.naturalWidth > 0) { imgH = panelW * (currentAiImage.naturalHeight / currentAiImage.naturalWidth); }

        const centerX = bx + panelW/2; const centerY = by + imgH/2 + 20; 
        c.translate(centerX, centerY); c.scale(scale, scale); c.translate(-centerX, -centerY);

        if (!isScanning) {
            let txtH = 40; const totalH = imgH + txtH;
            c.fillStyle = bgColor; c.fillRect(bx, by, panelW, totalH);
            c.fillStyle = borderColor; c.fillRect(bx, by, 4, totalH);
        }

        if(imgH > 0) {
            if (isScanning) {
                c.save();
                const radarRadiusBase = 50; const radarCx = bx + radarRadiusBase + 10; const radarCy = by + radarRadiusBase + 10;
                c.translate(radarCx, radarCy);
                c.strokeStyle = "rgba(0, 255, 100, 0.15)"; c.lineWidth = 1;
                for(let r=10; r<=radarRadiusBase; r+=10) { c.beginPath(); c.arc(0, 0, r, 0, Math.PI * 2); c.stroke(); }
                c.beginPath(); c.moveTo(-radarRadiusBase, 0); c.lineTo(radarRadiusBase, 0); c.stroke();
                c.beginPath(); c.moveTo(0, -radarRadiusBase); c.lineTo(0, radarRadiusBase); c.stroke();
                const pulse = (Math.sin(performance.now() * 0.003) + 1) / 2; 
                const currentRadius = radarRadiusBase * (0.6 + (pulse * 0.4)); 
                radarAngle += 0.04; c.rotate(radarAngle);
                const drawBlade = (angleOffset) => {
                    c.save(); c.rotate(angleOffset); c.beginPath(); c.moveTo(0,0); c.arc(0, 0, currentRadius, -0.4, 0.4); c.lineTo(0,0);
                    const grad = c.createRadialGradient(0, 0, 0, 0, 0, currentRadius);
                    grad.addColorStop(0, "rgba(0,0,0,0)"); 
                    if (pulse > 0.7) { grad.addColorStop(0.5, "rgba(255, 100, 0, 0.3)"); grad.addColorStop(1, "rgba(255, 0, 0, 0.6)"); } 
                    else { grad.addColorStop(0.5, "rgba(0, 150, 0, 0.3)"); grad.addColorStop(1, "rgba(200, 200, 0, 0.5)"); }
                    c.fillStyle = grad; c.fill(); c.restore();
                };
                drawBlade(0); drawBlade(Math.PI); c.restore();
                const txtX = radarCx + radarRadiusBase + 15; const txtY = radarCy; 
                if (displayTxt.includes('\n')) { const lines = displayTxt.split('\n'); let lineY = txtY - 15; lines.forEach((l, idx) => { drawGlitchText(c, l.toLowerCase(), txtX, lineY + (idx*14), 11); }); } 
                else { drawGlitchText(c, displayTxt.toLowerCase(), txtX, txtY + 5, 12); }
            } else {
                c.save(); c.filter = "invert(100%) grayscale(100%) contrast(1.5)"; c.drawImage(currentAiImage, bx, by, panelW, imgH); c.restore(); 
                c.strokeStyle = borderColor; c.lineWidth = 1; c.strokeRect(bx, by, panelW, imgH);
                c.fillStyle = "#ffcccc"; c.font = "10px 'Share Tech Mono'";
                let line = ''; let ly = by + imgH + 20;
                const resWords = currentAiText ? currentAiText.split(' ') : [];
                 for(let n = 0; n < resWords.length; n++) {
                    let testLine = line + resWords[n] + ' ';
                    if (c.measureText(testLine).width > (panelW - 20) && n > 0) { c.fillText(line.toLowerCase(), bx + 10, ly); line = resWords[n] + ' '; ly += 14; } else { line = testLine; }
                }
                c.fillText(line.toLowerCase(), bx + 10, ly);
            }
        }
        c.restore();
    }

    function renderLoop() {
        frameCount++;
        const vW = el.video.videoWidth, vH = el.video.videoHeight;
        const cW = el.canvas.width, cH = el.canvas.height;
        ctx.save();
        
        // TRUCO VISUAL: MOTION DECAY EN LUGAR DE CLEARRECT
        // Esto crea un arrastre sutil que conecta frames
        ctx.fillStyle = 'rgba(0,0,0,0.08)';
        ctx.fillRect(0,0,cW,cH);
        
        // OPTIMIZACI√ìN: ELIMINADO EL PROCESADO DE FILTROS POR CPU/CANVAS
        // if(state.filter === 'night') { ... } // DESACTIVADO
        
        if (vW && vH) {
            const vRatio = vW / vH, cRatio = cW / cH;
            let dW, dH, dX, dY;
            if (cRatio > vRatio) { dW = cW; dH = cW / vRatio; dX = 0; dY = (cH - dH) / 2; } 
            else { dW = cH * vRatio; dH = cH; dX = (cW - dW) / 2; dY = 0; }
            ctx.drawImage(el.video, 0, 0, vW, vH, dX, dY, dW, dH);
            window.drawCoords = { dW, dH, dX, dY, vW, vH };
            ctx.filter = 'none'; 
            // Las capas extras se dibujan en el canvas pero el filtro visual es externo
            if(state.filter === 'night') { ctx.fillStyle = 'rgba(0, 50, 0, 0.2)'; for(let i=0; i<cH; i+=4) ctx.fillRect(0, i, cW, 1); }
            if (state.isLidar) { ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fillRect(0,0, cW, cH); drawLidarEffect(ctx, cW, cH); }
        }
        ctx.restore(); 

        if (state.isSLS && !state.isLidar) drawSLS();
        const speed = 0.4;
        animState.hudScale += (animState.hudTarget - animState.hudScale) * speed;
        animState.aiScale += (animState.aiTarget - animState.aiScale) * speed;
        drawBurnInHUD(ctx, cW, cH, animState.hudScale);
        if (state.isPareidolia) drawCanvasScanBoxes(ctx, cW, cH);
        if (animState.aiTarget > 0.01 || animState.aiScale > 0.01) { drawAIBurnIn(ctx, cW, cH, animState.aiScale); }
        requestAnimationFrame(renderLoop);
    }

    async function aiLoop() {
        // OPTIMIZACI√ìN: CORTAFUEGOS DE IA
        // Si no hay ninguna funci√≥n de IA activa, terminamos inmediatamente para ahorrar bater√≠a y datos.
        if (!state.isSLS && !state.isLidar && !state.isPareidolia) return;
        if (isAIProcessing) return; 

        if (state.isLidar) { 
            // LIDAR AHORA TIENE SU PROPIO LOOP DESACOPLADO
            return; 
        } else {
            // OPTIMIZACI√ìN IA: Canvas reducido 224x224
            aiCtx.drawImage(el.video, 0, 0, aiCanvas.width, aiCanvas.height);
            if (aiDetector && state.isSLS) { try { poses = await aiDetector.estimatePoses(aiCanvas, { maxPoses: 5, flipHorizontal: false, scoreThreshold: 0.25 }); } catch(e){} }
            if (faceMesh && state.isSLS) { try { await faceMesh.send({image: el.video}); } catch(e){} }
        }
    }

    function drawSLS() {
        if (!window.drawCoords) return;
        const { dW, dH, dX, dY } = window.drawCoords;
        const mapX = (x) => (x / aiCanvas.width) * dW + dX; const mapY = (y) => (y / aiCanvas.height) * dH + dY;
        ctx.strokeStyle = '#d946ef'; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.fillStyle = '#a855f7';
        poses.forEach(pose => {
            const k = pose.keypoints;
            const bodyPairs = [[5,7],[7,9],[6,8],[8,10],[11,12],[11,13],[13,15],[12,14],[14,16],[5,11],[6,12]];
            ctx.beginPath(); bodyPairs.forEach(([i, j]) => { if(k[i].score > AI_SENSITIVITY && k[j].score > AI_SENSITIVITY) { ctx.moveTo(mapX(k[i].x), mapY(k[i].y)); ctx.lineTo(mapX(k[j].x), mapY(k[j].y)); } }); ctx.stroke();
            const nose = k[0], lEye = k[1], rEye = k[2], lShoulder = k[5], rShoulder = k[6];
            let neckX, neckY;
            if(lShoulder.score > AI_SENSITIVITY && rShoulder.score > AI_SENSITIVITY) {
                neckX = (mapX(lShoulder.x) + mapX(rShoulder.x)) / 2; neckY = (mapY(lShoulder.y) + mapY(rShoulder.y)) / 2;
                ctx.beginPath(); ctx.moveTo(mapX(lShoulder.x), mapY(lShoulder.y)); ctx.lineTo(neckX, neckY); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(mapX(rShoulder.x), mapY(rShoulder.y)); ctx.lineTo(neckX, neckY); ctx.stroke();
                if(nose.score > AI_SENSITIVITY) { ctx.beginPath(); ctx.moveTo(mapX(nose.x), mapY(nose.y)); ctx.lineTo(neckX, neckY); ctx.stroke(); }
            }
            if(nose.score > AI_SENSITIVITY) { if(lEye.score > AI_SENSITIVITY) { ctx.beginPath(); ctx.moveTo(mapX(lEye.x), mapY(lEye.y)); ctx.lineTo(mapX(nose.x), mapY(nose.y)); ctx.stroke(); } if(rEye.score > AI_SENSITIVITY) { ctx.beginPath(); ctx.moveTo(mapX(rEye.x), mapY(rEye.y)); ctx.lineTo(mapX(nose.x), mapY(nose.y)); ctx.stroke(); } }
            k.forEach((p, i) => { if(i === 3 || i === 4) return; if(p.score > AI_SENSITIVITY) { ctx.beginPath(); ctx.arc(mapX(p.x), mapY(p.y), 4, 0, 2*Math.PI); ctx.fill(); } });
        });
        if(faces.length > 0) {
            faces.forEach(face => {
                let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                face.forEach((pt) => { const x=pt.x*dW+dX; const y=pt.y*dH+dY; if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; });
                const pad=20; ctx.strokeStyle='red'; ctx.lineWidth=2; ctx.strokeRect(minX-pad, minY-pad, (maxX-minX)+pad*2, (maxY-minY)+pad*2);
                ctx.fillStyle='#39ff14'; face.forEach((pt) => { ctx.fillRect(pt.x*dW+dX, pt.y*dH+dY, 1.5, 1.5); });
            });
        }
    }

    function updateClock() {
        const now = new Date(); const dateStr = now.toLocaleDateString('es-ES', {day: '2-digit', month: '2-digit', year: 'numeric'}); const timeStr = now.toLocaleTimeString();
        const clockEl = document.getElementById('hud-time'); if (clockEl) clockEl.innerText = `${dateStr} - ${timeStr}`;
    }

    function updateStatusDisplay() {
        const statusEl = document.getElementById('status-text');
        const dotEl = document.getElementById('status-dot');
        const tallyEl = document.getElementById('tally-border');
        
        // Determinar estado de conexi√≥n
        const isConnected = (conn && conn.open);
        
        if (!isConnected) {
            // ESTADO: DESCONECTADO (LOCAL)
            statusEl.innerText = "LOCAL";
            statusEl.className = "text-gray-500 font-mono font-bold tracking-widest";
            dotEl.className = "w-2 h-2 rounded-full bg-neutral-600";
            
            // Reset Tally
            tallyEl.className = "";
            tallyEl.style.border = "none";
            tallyEl.style.boxShadow = "none";
            return;
        }

        // ESTADO: CONECTADO - Revisar Tally
        if (tallyState === 'program') {
            // AL AIRE
            statusEl.innerText = "AL AIRE";
            statusEl.className = "text-white bg-red-600 px-1 rounded font-bold font-mono animate-pulse tracking-widest";
            dotEl.className = "w-2 h-2 rounded-full bg-red-500 shadow-[0_0_10px_red]";
            
            tallyEl.className = "online";
            tallyEl.style.border = "6px solid #ff0000";
            tallyEl.style.boxShadow = "inset 0 0 20px rgba(255,0,0,0.5)";
            tallyEl.style.opacity = "1";
        } 
        else if (tallyState === 'preview') {
            // PREVIO
            statusEl.innerText = "PREVIO";
            statusEl.className = "text-black bg-green-500 px-1 rounded font-bold font-mono tracking-widest";
            dotEl.className = "w-2 h-2 rounded-full bg-green-400 shadow-[0_0_10px_lime]";
            
            tallyEl.className = "preview";
            tallyEl.style.border = "4px solid #00ff00";
            tallyEl.style.boxShadow = "none";
            tallyEl.style.opacity = "0.8";
        } 
        else {
            // LISTO (IDLE)
            statusEl.innerText = "LISTO";
            statusEl.className = "text-cyan-500 font-mono font-bold tracking-widest";
            dotEl.className = "w-2 h-2 rounded-full bg-cyan-500 shadow-[0_0_5px_cyan]";
            
            tallyEl.className = "";
            tallyEl.style.border = "none";
            tallyEl.style.boxShadow = "none";
        }
    }

    function telemetryLoop() {
        const now = performance.now(); const elapsed = now - lastTime;
        if (elapsed >= 1000) { currentFps = Math.round((frameCount * 1000) / elapsed); frameCount = 0; lastTime = now; }
        updateClock(); 
        let signal = 0; if(peerCommand && !peerCommand.disconnected && !peerCommand.destroyed) signal++; if(conn && conn.open) signal++; if(peerVideoSender && !peerVideoSender.disconnected) signal++;
        const vW = el.video.videoWidth || 0, vH = el.video.videoHeight || 0;
        document.getElementById('meta-res').innerText = `${vW}x${vH}`; document.getElementById('meta-fps').innerText = `${currentFps} FPS`;
        document.getElementById('signal-ui').className = `signal-bars signal-level-${signal}`;
        
        // Llamada a la nueva funci√≥n centralizada de estado (√önica fuente de verdad)
        updateStatusDisplay();
    }

    function openConnect() { document.getElementById('connect-modal').classList.add('active'); }

    async function startHybridTransmission() {
        const name = document.getElementById('stream-name').value.trim(); if(!name) return;
        const fullId = state.studioId; 
        if(!fullId) { showToast("ID ESTUDIO VACIO", true); return; }
        
        document.getElementById('connect-modal').classList.remove('active'); showToast("Conectando...", false);
        state.isStreaming = true; // Flag de Streaming
        
        let baseId = fullId;
        if (baseId.endsWith("-8889")) { baseId = baseId.slice(0, -5); }
        if (baseId.includes('.')) { baseId = baseId.replace(/\./g, '-'); }
        
        const commandTarget = baseId + "-8889"; 
        const videoTarget = baseId + "-8889";
        
        if(peerCommand) peerCommand.destroy();
        peerCommand = new Peer(null, PEER_CONFIG);
        
        peerCommand.on('open', () => {
            const connection = peerCommand.connect(commandTarget);
            
            connection.on('open', () => {
                conn = connection;
                conn.send({ type: 'register', name: name, hasAI: true });
                showToast("Enlace Comandos OK", false);
            });
            
            connection.on('data', handleCommand);
            connection.on('close', () => { showToast("Estudio desconectado", true); conn = null; state.isStreaming = false; });
            connection.on('error', (e) => { console.error("Data error", e); });
        });
        
        peerCommand.on('error', (err) => { console.error("PeerCMD Error:", err); showToast("Err CMD: " + err.type, true); });

        if(peerVideoSender) peerVideoSender.destroy();
        peerVideoSender = new Peer(null, PEER_CONFIG);
        
        peerVideoSender.on('open', () => {
            const stream = el.canvas.captureStream(30); 
            const audioTracks = videoStream.getAudioTracks();
            if(audioTracks.length > 0) stream.addTrack(audioTracks[0]);
            
            const call = peerVideoSender.call(videoTarget, stream, { metadata: { name: name } });
            
            // OPTIMIZACI√ìN WEBRTC: Limitador de Bitrate (900 kbps)
            const sender = call.peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
            if (sender) {
                const params = sender.getParameters();
                if (!params.encodings) params.encodings = [{}];
                params.encodings[0].maxBitrate = 900000; // 900 kbps
                params.encodings[0].maxFramerate = 30;
                params.encodings[0].scaleResolutionDownBy = 1;
                sender.setParameters(params).catch(e => console.warn("Bitrate cap failed", e));
            }

            call.on('close', () => { console.log("Video call ended"); });
            call.on('error', (e) => { console.error("Video call error", e); });
            showToast("Transmitiendo Video...", false);
        });

        peerVideoSender.on('error', (err) => { console.error("PeerVID Error:", err); showToast("Err VID: " + err.type, true); });
    }

    function handleCommand(cmd) {
        showToast(`CMD: ${cmd.action?.toUpperCase() || cmd.type?.toUpperCase()}`);
        if(cmd.type === 'cmd' || cmd.category === 'cam') {
            const action = cmd.action;
            const value = cmd.value;
            if(action === 'filter') { 
                const map = { 'night':'btn-night', 'thermal':'btn-thermal', 'urbex':'btn-urbex', 'sls':'btn-sls', 'lidar':'btn-heatmap', 'normal': null }; 
                setFilter(value, document.getElementById(map[value])); 
            }
            else if(action === 'flash') toggleTorch(value); 
            else if(action === 'toggle' && value === 'pareidolia') togglePareidolia();
            else if(action === 'reset') setFilter('normal', null);
        }
        else if (cmd.type === 'tally') {
            // Actualizaci√≥n de estado global en lugar de manipulaci√≥n directa
            tallyState = cmd.state; 
            updateStatusDisplay(); // Forzar actualizaci√≥n visual inmediata
        }
    }

    function setFilter(f, btn) {
        if(state.filter === f && f !== 'normal') f = 'normal'; state.filter = f; state.isSLS = (f === 'sls'); state.isLidar = (f === 'lidar');
        document.querySelectorAll('.menu-btn').forEach(b => b.classList.remove('active-state')); if(btn && f !== 'normal') btn.classList.add('active-state');
        
        // GESTI√ìN DE CLASES CSS (OPTIMIZADO)
        // Removemos todas las clases de filtro y aplicamos solo la activa
        document.body.classList.remove('filter-night-vision', 'filter-thermal', 'filter-urbex', 'filter-pareidolia');
        
        if(f !== 'normal') { 
            if(f === 'night') document.body.classList.add('filter-night-vision'); 
            else if(f === 'thermal') document.body.classList.add('filter-thermal'); 
            else if(f === 'urbex') document.body.classList.add('filter-urbex'); 
            // CORRECCI√ìN VISUAL: SLS YA NO USA FILTRO GRIS
            else if(f === 'sls') { /* Sin filtro CSS, imagen limpia */ }
            else if(f === 'pareidolia') document.body.classList.add('filter-pareidolia'); 
        }
        
        if(f === 'night' || f === 'thermal') toggleTorch(true); else toggleTorch(false); 
        document.getElementById('sls-pip').style.display = state.isSLS ? 'block' : 'none'; poses = []; lidarMask = null; lastLidarMask = null;
    }

    async function toggleTorch(force) { const t = videoStream?.getVideoTracks()[0]; if(!t) return; const on = (typeof force === 'boolean') ? force : !t.getSettings().torch; try { await t.applyConstraints({advanced:[{torch:on}]}); } catch(e){} }

    function speakText(text) {
        if('speechSynthesis' in window) {
            window.speechSynthesis.cancel(); const cleanText = text.replace(/[\.,;:-]{2,}/g, '. ').replace(/[\n\r]/g, ' ');
            const u = new SpeechSynthesisUtterance(cleanText); u.lang = 'es-MX'; u.rate = 1.0; u.pitch = 1.1; 
            const voices = window.speechSynthesis.getVoices();
            const femaleVoice = voices.find(v => v.lang.includes('es') && (v.name.includes('Paulina') || v.name.includes('Sabina') || v.name.includes('Mexico') || v.name.toLowerCase().includes('female')));
            if (femaleVoice) u.voice = femaleVoice; window.speechSynthesis.speak(u);
        }
    }

    function startScanningEffect() {
        const overlay = document.getElementById('ai-scan-overlay'); overlay.innerHTML = ''; overlay.style.display = 'block';
        if (scanInterval) clearInterval(scanInterval);
        scanInterval = setInterval(() => {
            const box = document.createElement('div'); box.className = 'scan-box'; const size = Math.floor(Math.random() * 80) + 40;
            let x, y; do { x = Math.floor(Math.random() * (window.innerWidth - size)); y = Math.floor(Math.random() * (window.innerHeight - size)); } while (x < 250 && y < 200); 
            canvasScanBoxes.push({ x, y, size, startTime: Date.now() });
            box.style.width = `${size}px`; box.style.height = `${size}px`; box.style.left = `${x}px`; box.style.top = `${y}px`;
            overlay.appendChild(box); setTimeout(() => box.remove(), 800);
        }, 150); 
    }

    function stopScanningEffect() { clearInterval(scanInterval); const overlay = document.getElementById('ai-scan-overlay'); overlay.innerHTML = ''; overlay.style.display = 'none'; canvasScanBoxes = []; }

    async function triggerPareidolia() {
        if(!state.isPareidolia) return; // OPTIMIZACI√ìN: Check estricto
        const video = el.video; if(!GEMINI_API_KEY) return; if(isAIProcessing || window.speechSynthesis.speaking) return;
        const now = Date.now(); if (now - lastPareidoliaCall < 12000) return; lastPareidoliaCall = now;
        isAIProcessing = true; currentAiText = "b√∫squeda de se√±al..."; currentAiImage = null; startScanningEffect();
        const canvas = document.createElement('canvas'); canvas.width = 640; canvas.height = 360; canvas.getContext('2d').drawImage(video, 0, 0, 640, 360);
        const snapshot = new Image(); snapshot.src = canvas.toDataURL('image/jpeg', 0.8);
        const base64 = canvas.toDataURL('image/jpeg', 0.6).split(',')[1];
        const prompt = "Act√∫a como un m√©dium digital. Describe en primera persona lo que ves. Usa frases como 'Veo...', 'Hay algo en...', 'Est√°...'. Busca caras en las sombras. S√© siniestro. Max 12 palabras.";
        try {
            let attempts = 0, success = false, data = null;
            while(attempts < 3 && !success) {
                try {
                    const modelToUse = CURRENT_AI_MODEL || "gemini-2.5-flash-preview-09-2025";
                    const resp = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelToUse}:generateContent?key=${GEMINI_API_KEY}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/jpeg", data: base64 } }] }] }) });
                    data = await resp.json(); if (data.candidates && data.candidates[0].content) success = true; else { attempts++; await new Promise(r => setTimeout(r, 1000)); }
                } catch(err) { attempts++; }
            }
            let text = success ? (data.candidates?.[0]?.content?.parts?.[0]?.text || "ANOMALIA DETECTADA").replace(/[*_]/g, '').trim() : "SE√ëAL DEBIL...";
            stopScanningEffect(); currentAiText = text; currentAiImage = snapshot; 
            clearTimeout(aiTextTimer); aiTextTimer = setTimeout(() => { currentAiText = ""; currentAiImage = null; if (state.isPareidolia) { startScanningEffect(); } }, 9000);
            if (conn && conn.open) { conn.send({ type: 'ai-speech', text: text }); }
            speakText(text);
        } catch(e) { isAIProcessing = false; currentAiText = "error de se√±al"; setTimeout(() => { if(currentAiText === "error de se√±al") { currentAiText = ""; if (state.isPareidolia) startScanningEffect(); } }, 3000); }
        isAIProcessing = false; 
    }

    function togglePareidolia(btnElement) {
        if(!GEMINI_API_KEY) { alert("NO API KEY: CONFIGURA EN AJUSTES"); return; }
        const btn = btnElement || document.getElementById('btn-ia'); isPareidoliaActive = !isPareidoliaActive; state.isPareidolia = isPareidoliaActive;
        const aiHeader = document.getElementById('ai-vision-header');
        if(isPareidoliaActive) {
            if(btn) btn.classList.add('active-state'); document.body.classList.add('filter-pareidolia'); speakText("VISI√ìN ACTIVADA"); 
            animState.hudTarget = 0.0; animState.aiTarget = 1.0;
            currentAiText = ""; currentAiImage = null; startScanningEffect(); triggerPareidolia(); pareidoliaInterval = setInterval(triggerPareidolia, 12000);
        } else {
            if(btn) btn.classList.remove('active-state'); document.body.classList.remove('filter-pareidolia'); speakText("VISI√ìN DESACTIVADA"); 
            animState.hudTarget = 1.0; animState.aiTarget = 0.0;
            clearInterval(pareidoliaInterval); isAIProcessing = false; stopScanningEffect(); currentAiText = ""; currentAiImage = null;
        }
        showMenus();
    }

    async function validateAndSaveKey() {
        const input = document.getElementById('api-key-internal'), btn = document.getElementById('btn-validate-api'), status = document.getElementById('api-status-msg'), k = input.value.trim();
        if(!k) { status.innerText = "‚ùå CAMPO VACIO"; return; }
        input.disabled = true; btn.disabled = true; const modelsToTry = ["gemini-2.5-flash-preview-09-2025", "gemini-1.5-flash", "gemini-1.5-pro"]; let workingModel = null;
        for(const step of ["CONECTANDO...", "ENVIANDO PING...", "VERIFICANDO..."]) { status.innerText = step; await new Promise(r => setTimeout(r, 400)); }
        for (const model of modelsToTry) { try { const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${k}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ contents: [{ parts: [{ text: "ping" }] }] }) }); if(response.ok) { workingModel = model; break; } } catch(e) {} }
        if(workingModel) {
            status.innerText = "‚úÖ ACTIVA (" + workingModel.replace("gemini-","").split("-")[0] + ")"; status.style.color = "#00ff41";
            GEMINI_API_KEY = k; CURRENT_AI_MODEL = workingModel; state.apiKey = k; state.aiModel = workingModel;
            localStorage.setItem('obr_gemini_key', k); localStorage.setItem('obr_ai_model', workingModel);
        } else { status.innerText = "‚ùå ERROR: LLAVE INVALIDA"; status.style.color = "red"; }
        input.disabled = false; btn.disabled = false;
    }

    function saveSettings() { 
        const rawIp = document.getElementById('mtx-host').value.trim();
        if(!rawIp) { showToast("Ingresa un ID v√°lido", true); return; }
        state.studioId = rawIp; 
        localStorage.setItem('obr_studio_id', state.studioId);
        showToast("Config Guardada"); 
        document.getElementById('settings-modal').classList.remove('active');
    }

    function openSettings() { document.getElementById('settings-modal').classList.add('active'); }
    let menuTimeout; const menus = [document.getElementById('menu-left'), document.getElementById('menu-right')];
    document.getElementById('touch-surface').addEventListener('click', showMenus);
    function showMenus() { menus.forEach(m => m.classList.add('visible')); clearTimeout(menuTimeout); menuTimeout = setTimeout(() => menus.forEach(m => m.classList.remove('visible')), 4000); }
    function showToast(msg, isError = false) { const t = document.createElement('div'); t.className = `toast ${isError ? 'error' : ''}`; t.innerText = msg; document.getElementById('toast-container').appendChild(t); setTimeout(() => t.remove(), 3000); }
    let pressTimer; const touchSurface = document.getElementById('touch-surface');
    touchSurface.addEventListener('pointerdown', (e) => { pressTimer = setTimeout(() => { state.zoom = state.zoom === 1 ? 2.5 : 1; const w = window.innerWidth, h = window.innerHeight, xPct = (e.clientX / w) * 100, yPct = (e.clientY / h) * 100; el.zoom.style.transformOrigin = `${xPct}% ${yPct}%`; el.zoom.style.transform = `scale(${state.zoom})`; const ind = document.getElementById('zoom-target-indicator'); ind.style.left = e.clientX+'px'; ind.style.top = e.clientY+'px'; ind.classList.add('active'); setTimeout(()=>ind.classList.remove('active'),500); if(navigator.vibrate) navigator.vibrate(50); }, 500); });
    touchSurface.addEventListener('pointerup', () => clearTimeout(pressTimer)); touchSurface.addEventListener('pointermove', () => clearTimeout(pressTimer));
    function resetZoom(btn) { state.zoom = 1; el.zoom.style.transform = `scale(1)`; if(btn) btn.classList.add('active-state'); setTimeout(()=>btn?.classList.remove('active-state'), 200); }
</script>
</body>
</html>
