<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>CAMARA OBR v160 (FIXED LOOP)</title> 
    
    <link rel="icon" type="image/png" href="obr-logo.png">
    <link rel="apple-touch-icon" href="obr-logo.png">
    <link rel="manifest" href='data:application/manifest+json,{"name":"OBR CAM","short_name":"OBR","start_url":".","display":"standalone","background_color":"#000000","theme_color":"#000000","icons":[{"src":"obr-logo.png","sizes":"192x192","type":"image/png"},{"src":"obr-logo.png","sizes":"512x512","type":"image/png"}]}'>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- CORE AI ENGINE -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>
    
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        * { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; box-sizing: border-box; outline: none; touch-action: none; }
        
        :root { --hud-primary: #ff3333; }

        body { 
            background: #000; overflow: hidden; 
            font-family: 'Orbitron', sans-serif; 
            width: 100vw; height: 100vh;
            margin: 0; padding: 0;
        }

        @media screen and (orientation: portrait) {
            body {
                transform: rotate(90deg);
                transform-origin: bottom left;
                position: absolute;
                top: -100vw; left: 0;
                height: 100vw; width: 100vh;
            }
        }
        
        #main-view-area { position: absolute; inset: 0; background: #000; overflow: hidden; }
        
        #zoom-container { 
            position: absolute; inset: 0; width: 100%; height: 100%;
            transform-origin: center center; 
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); 
            will-change: transform;
        }

        #shared-video-element { 
            position: absolute; inset: 0; width: 100%; height: 100%; 
            object-fit: cover; z-index: 0; 
        }
        
        #sls-canvas { 
            position: absolute; inset: 0; width: 100%; height: 100%; 
            object-fit: cover; z-index: 2; pointer-events: none; 
        }
        
        /* FILTROS CSS */
        .filter-night-vision #shared-video-element { filter: grayscale(100%) contrast(1.4) brightness(1.3) sepia(100%) hue-rotate(90deg) saturate(200%) !important; }
        .filter-night-vision #main-view-area::after { content: ""; position: absolute; inset: 0; pointer-events: none; background: radial-gradient(circle, rgba(0, 255, 50, 0.05) 40%, rgba(0,0,0,0.6) 95%); background-image: repeating-linear-gradient(0deg, rgba(0,255,0,0.02), rgba(0,255,0,0.02) 1px, transparent 1px, transparent 3px); z-index: 5; mix-blend-mode: hard-light; }
        
        .filter-thermal #shared-video-element { filter: invert(100%) contrast(1.2); }
        .filter-thermal #main-view-area::after { display: none; }
        
        .filter-urbex #shared-video-element { filter: sepia(100%) contrast(1.2) brightness(1.3) saturate(1.5); }
        .filter-urbex #main-view-area::after { content: ""; position: absolute; inset: 0; pointer-events: none; z-index: 5; box-shadow: inset 0 0 150px rgba(50,30,0,0.6); mix-blend-mode: multiply; }
        
        .filter-pareidolia #main-view-area { border: 2px solid var(--hud-primary); }

        /* UI LAYERS */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 20; }
        .interactive { pointer-events: auto; }
        
        #tally-border { position: absolute; inset: 0; border: 0px solid transparent; transition: border-width 0.2s; z-index: 50; pointer-events: none; }
        #tally-border.program { border: 12px solid red; box-shadow: inset 0 0 40px red; }
        #tally-border.preview { border: 12px solid #00ff00; }

        /* AI VISION UI */
        #ai-vision-header {
            position: absolute; top: 80px; left: 20px; 
            display: flex; flex-direction: column; align-items: flex-start;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
            z-index: 60; width: 220px;
        }
        #ai-vision-header.active { opacity: 1; }
        
        #ai-mini-img {
            width: 100%; height: auto; border: 2px solid #ff3333;
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.4);
            filter: invert(1) hue-rotate(180deg) contrast(1.5);
            margin-bottom: 0; background: black; display: block;
        }
        
        #ai-mini-text {
            width: 100%; background: rgba(10, 0, 0, 0.95);
            border: 1px solid #ff3333; border-top: none; border-left: 4px solid #ff3333;
            color: #ffcccc; font-family: 'Share Tech Mono', monospace; font-size: 0.8rem;
            padding: 8px; text-align: left; text-transform: uppercase;
            box-shadow: 0 5px 15px rgba(0,0,0,0.8); text-shadow: 0 0 5px red; line-height: 1.2;
        }

        /* MENUS */
        .menu-container { position: absolute; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 15px; z-index: 100; pointer-events: auto; transition: opacity 0.2s; opacity: 0; pointer-events: none; }
        .menu-container.visible { opacity: 1; pointer-events: auto; }
        .menu-container.left-side { left: 20px; }
        .menu-container.right-side { right: 20px; }
        
        .menu-btn { width: 50px; height: 50px; border: 2px solid #ff3333; border-radius: 50%; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; color: #ff3333; font-size: 1.2rem; cursor: pointer; backdrop-filter: blur(4px); box-shadow: 0 0 15px rgba(0,0,0,0.5); transition: all 0.2s; }
        .menu-btn:active { transform: scale(0.9); }
        .menu-btn.active-state { background: white; border-color: white; color: black; box-shadow: 0 0 20px white; }
        .menu-label { font-size: 0.55rem; color: white; text-align: center; margin-top: 4px; font-family: 'Share Tech Mono'; text-shadow: 1px 1px 2px black; background: rgba(0,0,0,0.6); padding: 1px 4px; border-radius: 4px; }

        /* LOADING */
        #loading { position: fixed; inset: 0; z-index: 200; background: black; display: flex; flex-direction: column; align-items: center; justify-content: center; background: radial-gradient(circle, #220000 0%, #000000 100%); }
        .load-btn { background: rgba(20,0,0,0.6); border: 2px solid #ff3333; color: #ff3333; padding: 18px 40px; font-size: 1.1rem; margin-top: 30px; cursor: pointer; font-weight: bold; clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px); transition: 0.2s; }
        
        /* MODALS */
        .modal-bg { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 300; display: none; align-items: center; justify-content: center; pointer-events: auto; }
        .modal-bg.active { display: flex; }
        
        /* TOUCH SURFACE */
        #touch-surface { position: absolute; inset: 0; z-index: 15; pointer-events: auto; }
        #zoom-target-indicator { 
            position: absolute; width: 60px; height: 60px; 
            border: 2px solid #00ff00; border-radius: 50%; 
            transform: translate(-50%, -50%) scale(0.5); opacity: 0; 
            pointer-events: none; z-index: 80; 
            box-shadow: 0 0 15px #00ff00;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s;
        }
        #zoom-target-indicator.active { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        
        #sls-pip { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); color: #00ff00; font-family: 'Share Tech Mono'; font-size: 0.8rem; display: none; text-shadow: 0 0 5px #00ff00; background: rgba(0,0,0,0.6); padding: 2px 8px; border: 1px solid #00ff00; border-radius: 4px; }
        #perf-stats { position: absolute; bottom: 5px; right: 5px; font-family: 'Share Tech Mono', monospace; font-size: 0.55rem; color: rgba(0, 255, 0, 0.6); background: rgba(0,0,0,0.4); padding: 2px 4px; border-radius: 4px; pointer-events: none; z-index: 80; text-align: right; }

        /* RECUADROS DE ESCANEO */
        .scan-rect { position: absolute; border: 2px solid rgba(0, 255, 65, 0.9); box-shadow: 0 0 15px rgba(0, 255, 65, 0.6); z-index: 55; pointer-events: none; background: rgba(0, 255, 0, 0.05); animation: scanBlinkBlur 0.8s forwards ease-out; }
        @keyframes scanBlinkBlur {
            0% { opacity: 0; transform: scale(0.8); filter: blur(0px); }
            30% { opacity: 1; transform: scale(1); filter: blur(0px); border-color: #00ff41; }
            80% { opacity: 1; transform: scale(1); filter: blur(2px); border-color: red; }
            100% { opacity: 0; transform: scale(1.2); filter: blur(8px); border-color: transparent; }
        }
    </style>
</head>
<body>

    <div id="main-view-area">
        <div id="zoom-container">
            <!-- VIDEO SOURCE -->
            <video id="shared-video-element" autoplay playsinline muted></video>
            <!-- CANVAS VISIBLE -->
            <canvas id="sls-canvas"></canvas>
        </div>
    </div>

    <div id="scan-layer" class="absolute inset-0 pointer-events-none overflow-hidden z-50"></div>
    <div id="touch-surface"></div>
    <div id="zoom-target-indicator"></div>

    <div id="ui-layer">
        <div id="tally-border"></div>
        <div id="sls-pip">● SLS ACTIVO</div>
        
        <div id="link-status" class="absolute bottom-4 left-4 text-[10px] font-mono text-gray-400 bg-black/60 px-2 py-1 rounded border border-gray-800">OFFLINE</div>
        <div class="absolute top-4 right-4 interactive text-gray-500 cursor-pointer p-2 bg-black/30 rounded-full" onclick="openSettings()"><i class="fas fa-cog text-xl"></i></div>

        <div id="perf-stats">INIT...</div>

        <!-- MENUS -->
        <div id="menu-left" class="menu-container left-side">
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('night', this)" ondblclick="setFilter('normal', null)"><i class="fas fa-moon"></i></div><div class="menu-label">NOCT</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('thermal', this)" ondblclick="setFilter('normal', null)"><i class="fas fa-fire"></i></div><div class="menu-label">TERM</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('urbex', this)" ondblclick="setFilter('normal', null)"><i class="fas fa-city"></i></div><div class="menu-label">URBEX</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('sls', this)" ondblclick="setFilter('normal', null)"><i class="fas fa-ghost"></i></div><div class="menu-label">SLS</div></div>
        </div>

        <div id="menu-right" class="menu-container right-side">
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="togglePareidolia(this)" ondblclick="togglePareidolia(this)" id="btn-ia"><i class="fas fa-eye"></i></div><div class="menu-label">VISION</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="openConnect()"><i class="fas fa-link"></i></div><div class="menu-label">LINK</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="resetZoom(this)"><i class="fas fa-compress"></i></div><div class="menu-label">RESET</div></div>
        </div>

        <!-- IA VISION UI -->
        <div id="ai-vision-header">
            <img id="ai-mini-img" alt="Scan">
            <div id="ai-mini-text">ESPERANDO DATOS...</div>
        </div>
        
        <div id="ai-feedback-overlay" style="display:none"></div>
    </div>

    <!-- PANTALLA CARGA -->
    <div id="loading">
        <img src="obr-logo.png" class="w-24 h-24 object-contain mb-4 animate-pulse drop-shadow-[0_0_20px_rgba(220,38,38,0.5)]">
        <h1 class="text-3xl text-red-600 font-bold mb-1 tracking-widest font-orbitron">OBR CAM</h1>
        <p class="text-xs font-mono text-gray-500 mb-8">SYSTEM v160</p>
        <button class="load-btn" onclick="initApp()">INICIAR CÁMARA</button>
        <button id="pwa-btn" class="text-xs text-green-500 mt-6 border border-green-900 px-4 py-2 hidden interactive hover:bg-green-900/20" onclick="installPWA()">INSTALAR APP</button>
    </div>

    <!-- MODALS -->
    <div id="connect-modal" class="modal-bg">
        <div class="bg-neutral-900 border border-cyan-500 p-8 rounded-lg w-80 text-center shadow-[0_0_30px_rgba(0,255,255,0.1)]">
            <h3 class="text-cyan-400 mb-6 text-xl tracking-widest font-bold">ENLACE PRODOCK</h3>
            <input type="text" id="dock-id" placeholder="ID DEL DIRECTOR" class="w-full bg-black border border-gray-700 text-white p-4 text-center uppercase mb-6 text-xl outline-none focus:border-cyan-400 transition-colors rounded">
            <button onclick="connectToProdock()" class="w-full bg-cyan-900 text-white font-bold py-4 hover:bg-cyan-700 mb-4 rounded font-orbitron">CONECTAR</button>
            <button onclick="document.getElementById('connect-modal').classList.remove('active')" class="text-gray-500 text-xs hover:text-white">CANCELAR</button>
        </div>
    </div>

    <div id="settings-modal" class="modal-bg">
        <div class="bg-neutral-900 border border-red-900 p-6 rounded w-80 shadow-[0_0_30px_rgba(255,0,0,0.1)]">
            <h2 class="text-red-500 font-orbitron mb-4 font-bold">CONFIGURACIÓN</h2>
            <input type="password" id="api-key-internal" placeholder="GEMINI API KEY" class="w-full bg-black border border-gray-700 p-3 text-white mb-2 text-sm rounded outline-none focus:border-red-500">
            <button id="btn-validate-api" onclick="validateAndSaveKey()" class="w-full border border-green-700 text-green-500 py-3 rounded hover:bg-green-900/20 font-bold">VALIDAR Y GUARDAR</button>
            <div id="api-status-msg" class="text-xs font-mono mt-2 text-center text-yellow-500"></div>
            <a href="https://aistudio.google.com/api-keys" target="_blank" class="block w-full text-center text-[10px] text-blue-400 mt-4 underline cursor-pointer pointer-events-auto">CREAR API KEY</a>
            <button onclick="document.getElementById('settings-modal').classList.remove('active')" class="w-full mt-3 text-gray-500 text-xs hover:text-white">CERRAR</button>
        </div>
    </div>

<script>
    let API_KEY = localStorage.getItem("obr_gemini_key") || "";
    let CURRENT_AI_MODEL = localStorage.getItem("obr_ai_model") || "gemini-2.5-flash-preview-09-2025";
    let GEMINI_API_KEY = API_KEY; 

    let currentFilter = 'normal';
    let isSLSActive = false;
    let isPareidoliaActive = false;
    let isAIProcessing = false;
    let poseDetector = null; // Renamed to poseDetector
    let faceDetector = null;
    let poses = [];
    let faces = [];
    let zoomLevel = 1; 
    let zoomStage = 0; 
    let peer, conn;
    let deferredPrompt;
    let menuTimer;
    let videoStream;
    let fps = 0, frameCount = 0, lastTime = performance.now();
    let pareidoliaInterval = null;

    const video = document.getElementById('shared-video-element');
    const slsCanvas = document.getElementById('sls-canvas');
    const ctx = slsCanvas.getContext('2d', { alpha: true });
    const zoomLayer = document.getElementById('zoom-container');
    const touchSurface = document.getElementById('touch-surface');

    // CANVAS DE DETECCIÓN OPTIMIZADO (192px PARA 60FPS)
    const detCanvas = document.createElement('canvas');
    detCanvas.width = 192; detCanvas.height = 108; 
    const detCtx = detCanvas.getContext('2d', { willReadFrequently: true });

    // --- ZOOM PROGRESIVO ---
    let pressTimer = null;
    const LONG_PRESS_MS = 600;

    touchSurface.addEventListener('pointerdown', (e) => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const touchX = e.clientX;
        const touchY = e.clientY;
        const edgeThreshold = 100;

        if (touchX < edgeThreshold || touchX > w - edgeThreshold) { showMenus(); return; }

        pressTimer = setTimeout(() => { handleZoomPress(touchX, touchY); }, LONG_PRESS_MS);
    });

    touchSurface.addEventListener('pointerup', () => clearTimeout(pressTimer));
    touchSurface.addEventListener('pointerleave', () => clearTimeout(pressTimer));
    touchSurface.addEventListener('pointermove', () => clearTimeout(pressTimer));

    function handleZoomPress(x, y) {
        if(navigator.vibrate) navigator.vibrate(50);
        
        let nextZoom = 1;
        if(zoomLevel === 1) nextZoom = 3;
        else if(zoomLevel === 3) nextZoom = 5;
        if(zoomLevel === 5) return;

        const ind = document.getElementById('zoom-target-indicator');
        ind.style.left = x + 'px';
        ind.style.top = y + 'px';
        ind.classList.add('active');
        setTimeout(() => ind.classList.remove('active'), 500);

        const originX = (x / window.innerWidth) * 100;
        const originY = (y / window.innerHeight) * 100;

        zoomLayer.style.transformOrigin = `${originX}% ${originY}%`;
        zoomLayer.style.transform = `scale(${nextZoom})`;
        zoomLevel = nextZoom;
    }

    function showMenus() {
        const left = document.getElementById('menu-left');
        const right = document.getElementById('menu-right');
        left.classList.add('visible'); right.classList.add('visible');
        clearTimeout(menuTimer);
        menuTimer = setTimeout(() => { left.classList.remove('visible'); right.classList.remove('visible'); }, 4000);
    }

    function resetZoom(btn) {
        if(btn) { btn.classList.add('active-state'); setTimeout(()=>btn.classList.remove('active-state'), 200); }
        zoomStage = 0; zoomLevel = 1;
        zoomLayer.style.transform = `scale(1)`;
        setTimeout(() => { zoomLayer.style.transformOrigin = `center center`; }, 400);
        hideMenus();
    }

    // --- PWA & INIT ---
    window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); deferredPrompt = e; document.getElementById('pwa-btn').style.display = 'inline-block'; });
    async function installPWA() { if(deferredPrompt) deferredPrompt.prompt(); }
    window.onload = () => { if(API_KEY) document.getElementById('api-key-internal').value = API_KEY; };

    async function initApp() {
        const btn = document.querySelector('.load-btn');
        btn.innerText = "INICIANDO..."; btn.disabled = true;
        try {
            const camPromise = navigator.mediaDevices.getUserMedia({ 
                audio: true, 
                video: { facingMode: 'environment', width: { ideal: 4096 }, height: { ideal: 2160 }, frameRate: { ideal: 60 }, advanced: [{ focusMode: "continuous" }] } 
            }).catch(() => navigator.mediaDevices.getUserMedia({ audio: true, video: { facingMode: 'environment' } }));
            
            const posePromise = tf.setBackend('webgl').then(() => 
    poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        {
            modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
            enableSmoothing: false,
            minPoseScore: 0.05
        }
    )
);

            const facePromise = faceLandmarksDetection.createDetector(faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh, { runtime: 'tfjs', maxFaces: 1 });
            
            const [stream, poseDet, faceDet] = await Promise.all([camPromise, posePromise, facePromise]);
            videoStream = stream; video.srcObject = stream; 
            poseDetector = poseDet; faceDetector = faceDet;
            
            const dummyVideo = document.createElement('video');
            await poseDetector.estimatePoses(dummyVideo).catch(()=>{}); 

            video.onloadedmetadata = () => { 
                video.play();
                document.getElementById('loading').style.display = 'none';
                resize(); renderLoop(); 
                poseDetectionLoop(); 
                faceDetectionLoop(); 
            };
            window.addEventListener('resize', resize);
            setInterval(() => { if (video.paused && video.srcObject) video.play().catch(()=>{}); }, 2000);
        } catch(e) { alert("Error Inicio: " + e.message); location.reload(); }
    }

    function resize() { slsCanvas.width = window.innerWidth; slsCanvas.height = window.innerHeight; }

    // --- RENDER LOOP ---
    function renderLoop() {
        const now = performance.now(); frameCount++;
        if (now - lastTime >= 1000) {
            const t = video.srcObject ? video.srcObject.getVideoTracks()[0].getSettings() : null;
            document.getElementById('perf-stats').innerText = t ? `${t.width}x${t.height} @ ${frameCount}FPS` : `${frameCount}FPS`;
            frameCount = 0; lastTime = now;
        }

        ctx.clearRect(0, 0, slsCanvas.width, slsCanvas.height);
        
        ctx.filter = 'none'; 
        if(currentFilter === 'night') ctx.filter = 'grayscale(100%) sepia(100%) hue-rotate(90deg) contrast(1.4) brightness(1.3) saturate(2.0)';
        if(currentFilter === 'thermal') ctx.filter = 'invert(1) hue-rotate(180deg) contrast(1.2) saturate(1.2)';
        if(currentFilter === 'urbex') ctx.filter = 'sepia(100%) contrast(1.2) brightness(1.3) saturate(1.5)';

        // Calcular el recorte para "cover"
        const vRatio = video.videoWidth / video.videoHeight;
        const cRatio = slsCanvas.width / slsCanvas.height;
        let sW, sH, sX, sY;

        if (cRatio > vRatio) {
            sW = video.videoWidth;
            sH = video.videoWidth / cRatio;
            sX = 0;
            sY = (video.videoHeight - sH) / 2;
        } else {
            sW = video.videoHeight * cRatio;
            sH = video.videoHeight;
            sX = (video.videoWidth - sW) / 2;
            sY = 0;
        }

        ctx.drawImage(video, sX, sY, sW, sH, 0, 0, slsCanvas.width, slsCanvas.height);
        
        if(isSLSActive) {
            ctx.filter = 'none'; 
            drawSLS(poses, sX, sY, sW, sH);
            drawFaceMesh(faces, sX, sY, sW, sH);
        }

        requestAnimationFrame(renderLoop);
    }
    
    function getRenderCoords(xNorm, yNorm, sX, sY, sW, sH) {
        // xNorm/yNorm son pixeles en video original (no normalizados por MoveNet)
        const canvasX = ((xNorm - sX) / sW) * slsCanvas.width;
        const canvasY = ((yNorm - sY) / sH) * slsCanvas.height;
        return { x: canvasX, y: canvasY };
    }
    function adaptiveKeypoints(prev, curr) {
    if (!prev) return curr;

    return curr.map((kp, i) => {
        if (kp.score < 0.15 && prev[i]?.score > 0.3) {
            return {
                x: prev[i].x,
                y: prev[i].y,
                score: prev[i].score * 0.95
            };
        }
        return {
            x: kp.x,
            y: kp.y,
            score: Math.max(kp.score, 0.1)
        };
    });
}
    function humanShapeBoost(keypoints) {
    const head = keypoints[0];
    const ls = keypoints.find(p => p.name === 'left_shoulder');
    const rs = keypoints.find(p => p.name === 'right_shoulder');

    return (
        head?.score > 0.1 &&
        (ls?.score > 0.1 || rs?.score > 0.1)
    );
}
    function drawSLS(poses, sX, sY, sW, sH) {
        ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        
        poses.forEach(pose => {
    if (!humanShapeBoost(pose.keypoints)) return;

            // Cuerpo Térmico
            ctx.shadowBlur = 20; ctx.shadowColor = '#FF4500'; ctx.strokeStyle = 'rgba(255, 69, 0, 0.4)'; ctx.lineWidth = 25;
            ctx.beginPath(); 
            edges.forEach(([a,b]) => { 
                const p1=k.find(p=>p.name==a), p2=k.find(p=>p.name==b); 
                if(p1.score>0.15 && p2.score>0.15) { 
                    const c1 = getRenderCoords(p1.x, p1.y, sX, sY, sW, sH);
                    const c2 = getRenderCoords(p2.x, p2.y, sX, sY, sW, sH);
                    ctx.moveTo(c1.x, c1.y); ctx.lineTo(c2.x, c2.y); 
                } 
            }); 
            ctx.stroke();

            // Puntos de Unión
            ctx.fillStyle = '#FF0000'; ctx.shadowBlur = 10;
            k.forEach(p => {
                if(p.score > 0.15 && !p.name.includes('eye')) {
                    const c = getRenderCoords(p.x, p.y, sX, sY, sW, sH);
                    ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, 2*Math.PI); ctx.fill();
                }
            });
        });
    }

    function drawFaceMesh(faces, sX, sY, sW, sH) {
        if(faces.length === 0 && !lastKeypoints) return;
        
        faces.forEach(face => {
            const points = face.keypoints; 
            
            // Malla Facial
            ctx.fillStyle = 'rgba(0, 255, 255, 0.15)';
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            
            // Puntos
            for(let i=0; i<points.length; i+=3) {
                 const p = points[i];
                 const c = getRenderCoords(p.x, p.y, sX, sY, sW, sH);
                 ctx.fillRect(c.x, c.y, 1, 1);
            }
            
            // Caja Objetivo
            const xs = points.map(p => p.x);
            const ys = points.map(p => p.y);
            const minX = Math.min(...xs); const maxX = Math.max(...xs);
            const minY = Math.min(...ys); const maxY = Math.max(...ys);
            
            const tl = getRenderCoords(minX, minY, sX, sY, sW, sH);
            const br = getRenderCoords(maxX, maxY, sX, sY, sW, sH);
            const width = br.x - tl.x;
            const height = br.y - tl.y;

            ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 2; ctx.shadowBlur = 5;
            const len = 15;
            ctx.beginPath();
            ctx.moveTo(tl.x, tl.y+len); ctx.lineTo(tl.x, tl.y); ctx.lineTo(tl.x+len, tl.y);
            ctx.moveTo(br.x, br.y-len); ctx.lineTo(br.x, br.y); ctx.lineTo(br.x-len, br.y);
            ctx.moveTo(tl.x+width, tl.y+len); ctx.lineTo(tl.x+width, tl.y); ctx.lineTo(tl.x+width-len, tl.y);
            ctx.moveTo(tl.x, tl.y+height-len); ctx.lineTo(tl.x, tl.y+height); ctx.lineTo(tl.x+len, tl.y+height);
            ctx.stroke();
        });
    }

    let lastKeypoints = null;

async function poseDetectionLoop() {
    while(true) {
        if (poseDetector && (isSLSActive || isPareidoliaActive)) {
            try {
                const result = await poseDetector.estimatePoses(video, {
                    flipHorizontal: false
                });

                if (result.length > 0) {
                    const kp = adaptiveKeypoints(
                        lastKeypoints,
                        result[0].keypoints
                    );

                    lastKeypoints = kp;
                    poses = [{ keypoints: kp }];
                }
            } catch(e) {}
        } else {
            poses = [];
            lastKeypoints = null;
        }
        await new Promise(r => setTimeout(r, 33)); // ~30 FPS IA
    }
}


    async function faceDetectionLoop() {
        while(true) {
            if(faceDetector && isSLSActive) {
                try {
                    faces = await faceDetector.estimateFaces(video);
                } catch(e) { faces = []; }
            } else { faces = []; }
            await new Promise(r => setTimeout(r, 100)); // 10 FPS
        }
    }

    function openConnect() { document.getElementById('connect-modal').classList.add('active'); }
    async function connectToProdock() {
        const id = document.getElementById('dock-id').value.trim();
        if(!id) return;
        document.getElementById('connect-modal').classList.remove('active');
        peer = new Peer();
        peer.on('open', myId => {
            conn = peer.connect(id);
            conn.on('open', () => {
                document.getElementById('link-status').innerText = "ONLINE: PRODOCK";
                document.getElementById('link-status').className = "absolute bottom-4 left-4 text-[10px] font-mono text-green-400 bg-green-900/40 px-2 py-1 rounded border border-green-500 font-bold";
                conn.send({ type: 'register', name: 'CAM-' + myId.substr(0,3) });
            });
            conn.on('data', d => {
                if(d.type === 'tally') document.getElementById('tally-border').className = d.state !== 'idle' ? d.state : '';
                if(d.type === 'cmd') {
                    if(d.action === 'filter') setFilter(d.value); 
                    if(d.action === 'toggle' && d.value === 'pareidolia') togglePareidolia();
                    if(d.action === 'reset') { setFilter('normal'); resetZoom(); }
                }
            });
            const streamToSend = slsCanvas.captureStream(30); 
            const audioTrack = video.srcObject.getAudioTracks()[0];
            if(audioTrack) streamToSend.addTrack(audioTrack);
            peer.call(id, streamToSend);
        });
    }

    function setFilter(f, btn) {
        if(currentFilter === f && f !== 'normal') { setFilter('normal'); return; }
        currentFilter = f;
        isSLSActive = (f === 'sls');
        
        document.querySelectorAll('.menu-btn').forEach(b => b.classList.remove('active-state')); 
        if(btn && f !== 'normal') btn.classList.add('active-state');
        
        // CSS Fallback
        document.body.className = '';
        if(f === 'night') document.body.classList.add('filter-night-vision');
        if(f === 'thermal') document.body.classList.add('filter-thermal');
        if(f === 'urbex') document.body.classList.add('filter-urbex');
        if(f === 'sls') document.body.classList.add('filter-pareidolia');

        document.getElementById('sls-pip').style.display = isSLSActive ? 'block' : 'none';
        
        if(isPareidoliaActive) togglePareidolia();
    }

    function speakText(t) { 
        if ('speechSynthesis' in window) { 
            window.speechSynthesis.cancel(); 
            const u = new SpeechSynthesisUtterance(t); 
            u.lang = 'es-ES'; u.pitch = 0.6; u.rate = 0.9; 
            u.onend = () => { setTimeout(() => { isAIProcessing = false; }, 2000); };
            u.onerror = () => { isAIProcessing = false; };
            window.speechSynthesis.speak(u);
        } else { setTimeout(() => { isAIProcessing = false; }, 2000); }
    }

    async function triggerPareidolia() { 
        if(!GEMINI_API_KEY) return; 
        if(isAIProcessing || window.speechSynthesis.speaking) return; 
        isAIProcessing = true; 

        // NO TOCAR HEADER AQUI
        
        const canvas = document.createElement('canvas'); canvas.width = 640; canvas.height = 360; 
        canvas.getContext('2d').drawImage(video, 0, 0, 640, 360); 
        const base64 = canvas.toDataURL('image/jpeg', 0.6).split(',')[1]; 
        const prompt = "Actúa como un médium digital. Describe en primera persona lo que ves. Usa frases como 'Veo...', 'Hay algo en...', 'Está...'. Busca caras en las sombras. Sé siniestro. Max 12 palabras."; 
        try { 
            let attempts = 0; let success = false; let data = null;
            while(attempts < 3 && !success) {
                try {
                     const modelToUse = CURRENT_AI_MODEL || "gemini-2.5-flash-preview-09-2025";
                     const resp = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelToUse}:generateContent?key=${GEMINI_API_KEY}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/jpeg", data: base64 } }] }] }) }); 
                     data = await resp.json();
                     if (data.candidates && data.candidates[0].content) { success = true; } else { attempts++; await new Promise(r => setTimeout(r, 1000)); }
                } catch(err) { attempts++; }
            }
            let text = success ? (data.candidates?.[0]?.content?.parts?.[0]?.text || "ANOMALIA DETECTADA").replace(/[*_]/g, '').trim() : "SIN DATOS CLAROS";
            if(text.length < 3) text = "SIN DATOS CLAROS"; 
            const aiHeader = document.getElementById('ai-vision-header'); const aiImg = document.getElementById('ai-mini-img'); const aiText = document.getElementById('ai-mini-text');
            aiImg.src = canvas.toDataURL(); aiText.innerText = text.toUpperCase(); aiHeader.classList.add('active');
            speakText(text); 
        } catch(e) { console.log(e); isAIProcessing = false; } 
    }

    function togglePareidolia(btnElement) { 
        if(!GEMINI_API_KEY) { alert("NO API KEY"); return; } 
        const btn = btnElement || document.getElementById('btn-ia');
        isPareidoliaActive = !isPareidoliaActive; 
        if(isPareidoliaActive) { 
            if(btn) btn.classList.add('active-state');
            document.body.classList.add('filter-pareidolia'); 
            speakText("VISIÓN ACTIVADA"); triggerPareidolia(); pareidoliaInterval = setInterval(triggerPareidolia, 8000); 
        } else { 
            if(btn) btn.classList.remove('active-state');
            document.body.classList.remove('filter-pareidolia'); 
            speakText("VISIÓN DESACTIVADA"); clearInterval(pareidoliaInterval); 
            isAIProcessing = false; 
            const aiHeader = document.getElementById('ai-vision-header');
            aiHeader.classList.remove('active');
        } 
        showMenus(); 
    }

    async function validateAndSaveKey() { 
        const input = document.getElementById('api-key-internal'); 
        const btn = document.getElementById('btn-validate-api'); 
        const status = document.getElementById('api-status-msg'); 
        const k = input.value.trim(); 
        if(!k) { status.innerText = "❌ CAMPO VACIO"; return; } 
        input.disabled = true; btn.disabled = true; 
        const modelsToTry = ["gemini-2.5-flash-preview-09-2025", "gemini-1.5-flash", "gemini-1.5-pro"];
        let workingModel = null;
        for(const step of ["CONECTANDO...", "ENVIANDO PING...", "VERIFICANDO..."]) { status.innerText = step; await new Promise(r => setTimeout(r, 400)); } 
        for (const model of modelsToTry) {
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${k}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ contents: [{ parts: [{ text: "ping" }] }] }) }); 
                if(response.ok) { workingModel = model; break; }
            } catch(e) {}
        }
        if(workingModel) { 
            status.innerText = "✅ ACTIVA (" + workingModel.replace("gemini-","").split("-")[0] + ")"; status.style.color = "#00ff41"; 
            GEMINI_API_KEY = k; CURRENT_AI_MODEL = workingModel;
            localStorage.setItem('obr_gemini_key', k); localStorage.setItem('obr_ai_model', workingModel); 
        } else { status.innerText = "❌ ERROR: LLAVE INVALIDA"; status.style.color = "red"; } 
        input.disabled = false; btn.disabled = false; btn.innerText = "VALIDAR"; 
    }

    function openSettings() { document.getElementById('settings-modal').classList.add('active'); }
</script>
</body>
</html>
