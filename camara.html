<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CAMARA OBR PRO v6.1.5 (SENSOR FIX)</title> 
    
    <link rel="icon" type="image/png" href="obr-logo.png">
    <link rel="apple-touch-icon" href="obr-logo.png">
    <meta name="theme-color" content="#000000">
    
    <link rel="manifest" href='data:application/manifest+json,{"name":"OBR CAM PRO","short_name":"OBR CAM","start_url":".","display":"standalone","background_color":"#000000","theme_color":"#000000","icons":[{"src":"obr-logo.png","sizes":"192x192","type":"image/png"},{"src":"obr-logo.png","sizes":"512x512","type":"image/png"}]}'>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LIBRER√çAS -->
    <script src="js/tf.min.js"></script>
    <script src="js/pose-detection.min.js"></script>
    <script src="js/face_mesh.js"></script>
    <script src="js/selfie_segmentation.js"></script> 
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        if(!window.tf) document.write('<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"><\/script>');
        if(!window.poseDetection) document.write('<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3"><\/script>');
        if(!window.FaceMesh) document.write('<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"><\/script>');
        if(!window.SelfieSegmentation) document.write('<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"><\/script>');
    </script>
    
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        * { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; box-sizing: border-box; outline: none; touch-action: none; }
        :root { --hud-primary: #ff3333; }
        body { background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; width: 100vw; height: 100vh; margin: 0; padding: 0; }
        
        /* CONTENEDOR PRINCIPAL: AQUI SE APLICAN LOS FILTROS CSS */
        #main-view-area { position: absolute; inset: 0; background: #000; overflow: hidden; transition: filter 0.2s; }
        
        #zoom-container { position: absolute; inset: 0; width: 100%; height: 100%; transform-origin: center center; transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); will-change: transform; }
        
        /* VIDEO: Visible ahora para los filtros CSS */
        #shared-video-element { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; opacity: 1; pointer-events: none; }
        
        /* CANVAS: Se usa para transmitir y overlays. Se oculta localmente cuando hay filtros pesados */
        #sls-canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: 2; pointer-events: none; transition: opacity 0.2s; }
        
        #heatmap-buffer, #lidar-buffer { display: none; }

        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 20; }
        .interactive { pointer-events: auto; cursor: pointer; }
        
        #orientation-lock { position: fixed; inset: 0; z-index: 9999; background: #000; display: none; flex-direction: column; align-items: center; justify-content: center; }
        @media (orientation: portrait) { #orientation-lock { display: flex; } #ui-layer { display: none; } }

        /* --- SISTEMA H√çBRIDO DE FILTROS --- */
        
        /* 1. NOCT (Night Vision) */
        body.filter-night-vision #main-view-area { 
            filter: grayscale(100%) sepia(100%) hue-rotate(90deg) saturate(2.0) contrast(1.2) brightness(1.0);
        }
        /* Malla solo visible si el canvas se oculta */
        body.filter-night-vision #main-view-area::after {
            content: " "; position: absolute; inset: 0; pointer-events: none; z-index: 10;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.2) 0px, rgba(0,0,0,0.2) 1px, transparent 1px, transparent 3px);
            background-size: 100% 3px;
        }

        /* 2. NEG (Thermal) */
        body.filter-thermal #main-view-area { 
            filter: grayscale(75%) invert(75%) contrast(1.7) brightness(0.8);
        }

        /* 3. URBEX (Cine Mexicano) */
        body.filter-urbex #main-view-area { 
            filter: sepia(100%) hue-rotate(-20deg) saturate(2.5) contrast(1.3) brightness(0.7);
        }

        /* TRUCO DE RENDIMIENTO: Ocultar Canvas Local para filtros pesados */
        body.filter-night-vision #sls-canvas, 
        body.filter-thermal #sls-canvas, 
        body.filter-urbex #sls-canvas { 
            opacity: 0 !important; 
        }

        body.filter-night-vision .hud-burn-hidden, 
        body.filter-thermal .hud-burn-hidden, 
        body.filter-urbex .hud-burn-hidden { 
            display: block !important; 
        }

        /* Por defecto el HUD HTML est√° oculto (porque lo dibuja el Canvas) */
        .hud-burn-hidden { display: none; }

        #tally-border { position: absolute; inset: 0; border: 0px solid transparent; transition: all 0.3s; z-index: 50; pointer-events: none; }
        #tally-border.preview { border: 4px solid #800000; opacity: 0.6; }
        #tally-border.online { border: 6px solid #00ff00; box-shadow: inset 0 0 20px rgba(0,255,0,0.5), 0 0 15px rgba(0,255,0,0.5); opacity: 1; }

        #ai-scan-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 55; display: none; overflow: hidden; }
        
        .scan-box { 
            position: absolute; 
            border: 2px solid rgba(255, 0, 0, 0.9); 
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6), inset 0 0 10px rgba(255, 0, 0, 0.3); 
            background: rgba(255, 0, 0, 0.1); 
            opacity: 0; 
            animation: targetScan 0.6s ease-out forwards; 
        }
        @keyframes targetScan { 
            0% { transform: scale(1.3); opacity: 0; border-color: white; } 
            10% { opacity: 1; border-color: red; } 
            80% { transform: scale(1); opacity: 1; } 
            100% { transform: scale(0.8); opacity: 0; } 
        }

        #toast-container { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 8px; z-index: 200; pointer-events: none; width: 80%; align-items: center; }
        .toast { background: rgba(0, 30, 0, 0.9); border: 1px solid #00ff00; color: #00ff00; padding: 10px 20px; border-radius: 4px; font-family: 'Share Tech Mono'; font-size: 14px; text-shadow: 0 0 5px #00ff00; box-shadow: 0 4px 15px rgba(0,0,0,0.8); animation: slideDown 0.3s ease-out; pointer-events: auto; text-align: center; }
        .toast.error { border-color: red; color: red; background: rgba(30, 0, 0, 0.9); text-shadow: 0 0 5px red; }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

        .menu-container { position: absolute; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 15px; z-index: 100; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
        .menu-container.visible { opacity: 1; pointer-events: auto; }
        .menu-container.left-side { left: 20px; }
        .menu-container.right-side { right: 20px; }
        .menu-btn { width: 50px; height: 50px; border: 2px solid var(--hud-primary); border-radius: 50%; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; color: var(--hud-primary); font-size: 1.2rem; backdrop-filter: blur(4px); transition: all 0.2s; cursor: pointer; pointer-events: auto; }
        .menu-btn:active { transform: scale(0.9); }
        .menu-btn.active-state { background: white; border-color: white; color: black; box-shadow: 0 0 20px white; }
        .menu-label { font-size: 0.55rem; color: white; text-align: center; margin-top: 4px; font-family: 'Share Tech Mono'; background: rgba(0,0,0,0.6); border-radius: 4px; }

        #telemetry-container { position: absolute; bottom: 10px; right: 10px; display: flex; flex-direction: column; align-items: flex-end; gap: 2px; pointer-events: none; z-index: 150; }
        .stat-row { font-family: 'Share Tech Mono', monospace; font-size: 10px; color: rgba(0, 255, 0, 0.7); text-shadow: 1px 1px 0px black; background: rgba(0,0,0,0.3); padding: 1px 4px; border-radius: 2px; display: flex; align-items: center; gap: 6px; }
        .signal-bars { display: flex; align-items: flex-end; gap: 2px; height: 12px; width: 16px; }
        .bar { width: 4px; background: #333; border-radius: 1px; transition: background 0.3s; }
        .bar:nth-child(1) { height: 33%; } .bar:nth-child(2) { height: 66%; } .bar:nth-child(3) { height: 100%; }
        .signal-level-0 .bar { background: #333; }
        .signal-level-1 .bar:nth-child(1) { background: #ff3333; }
        .signal-level-2 .bar:nth-child(1), .signal-level-2 .bar:nth-child(2) { background: #ffff00; }
        .signal-level-3 .bar { background: #00ff00; }

        #loading { position: fixed; inset: 0; z-index: 200; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .modal-bg { position: fixed; inset: 0; z-index: 300; background: rgba(0,0,0,0.95); display: none; align-items: center; justify-content: center; }
        .modal-bg.active { display: flex; }
        #progress-bar { height: 100%; width: 0%; background: var(--hud-primary); transition: width 0.3s; }
        
        #zoom-target-indicator { position: absolute; width: 60px; height: 60px; border: 2px solid #00ff00; border-radius: 50%; transform: translate(-50%, -50%) scale(0.5); opacity: 0; pointer-events: none; z-index: 80; transition: transform 0.3s, opacity 0.3s; }
        #zoom-target-indicator.active { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    </style>
</head>
<body>

    <div id="orientation-lock">
        <i class="fas fa-mobile-alt text-4xl mb-4 rotate-90 text-red-500"></i>
        <h2 class="text-xl font-bold font-orbitron tracking-widest text-red-500">GIRAR DISPOSITIVO</h2>
    </div>

    <div id="main-view-area">
        <div id="zoom-container">
            <video id="shared-video-element" autoplay playsinline muted></video>
            <canvas id="sls-canvas"></canvas>
        </div>
        <div id="ai-scan-overlay"></div>
    </div>
    <canvas id="heatmap-buffer"></canvas>
    <canvas id="lidar-buffer"></canvas>
    
    <div id="touch-surface" class="absolute inset-0 z-10 interactive"></div>
    <div id="zoom-target-indicator"></div>

    <div id="ui-layer">
        <!-- HUD HTML (VISIBLE SOLO SI EL CANVAS SE OCULTA POR RENDIMIENTO) -->
        <div id="hud-layer" class="hud-burn-hidden">
            <img src="obr-logo.png" id="hud-logo" class="absolute top-5 left-5 w-10 h-10 opacity-90" alt="OBR">
            <div id="hud-text-container" class="absolute top-5 left-20">
                <div id="hud-title" class="text-white font-orbitron font-bold text-base shadow-black drop-shadow-md">EXPLORACIONES OBR</div>
                <div id="hud-time" class="text-[#ff3333] font-mono text-xs shadow-black drop-shadow-md">--/--/-- - --:--:--</div>
            </div>
        </div>

        <div id="toast-container"></div>
        <div id="tally-border" class="preview"></div>
        
        <div id="link-status" class="absolute bottom-4 left-4 text-[10px] font-mono text-gray-400 bg-black/60 px-2 py-1 rounded border border-gray-800 flex items-center gap-2">
            <div id="status-dot" class="w-2 h-2 rounded-full bg-red-900"></div>
            <span id="status-text">PREVIEW</span>
        </div>

        <!-- GRUPO SUPERIOR DERECHO: BATERIA, RED Y AJUSTES -->
        <!-- NOTA: Para cambiar el orden, mueve los bloques div marcados dentro de este contenedor padre -->
        <div id="top-right-group" class="absolute top-4 right-4 flex items-center gap-3 z-50 pointer-events-auto">
            
            <!-- [BLOQUE 1]: INDICADOR DE BATER√çA -->
            <div id="battery-indicator" class="flex items-center gap-2 text-gray-400 bg-black/60 border border-gray-700 px-3 py-1 rounded-full text-[10px] font-mono hidden backdrop-blur-sm transition-colors duration-300">
                <i id="battery-icon" class="fas fa-battery-full"></i>
                <span id="battery-level">--%</span>
            </div>

            <!-- [BLOQUE 2]: INDICADOR DE RED M√ìVIL -->
            <div id="network-indicator" class="flex items-center gap-2 text-gray-400 bg-black/60 border border-gray-700 px-3 py-1 rounded-full text-[10px] font-mono hidden backdrop-blur-sm transition-colors duration-300">
                <i class="fas fa-signal"></i>
                <span id="network-type">--</span>
            </div>

            <!-- [BLOQUE 3]: BOT√ìN CONFIGURACI√ìN -->
            <div class="interactive text-gray-400 p-2 bg-black/60 border border-gray-700 rounded-full hover:text-white hover:border-red-500 transition-colors backdrop-blur-sm" onclick="openSettings()">
                <i class="fas fa-cog text-xl"></i>
            </div>
        </div>
        
        <div id="telemetry-container">
            <div class="stat-row"><span id="meta-res">INIT...</span><i class="fas fa-expand text-[8px]"></i></div>
            <div class="stat-row"><span id="meta-fps">-- FPS</span><div class="signal-bars signal-level-0" id="signal-ui"><div class="bar"></div><div class="bar"></div><div class="bar"></div></div></div>
        </div>

        <div id="menu-left" class="menu-container left-side">
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('night', this)" id="btn-night"><i class="fas fa-moon"></i></div><div class="menu-label">NOCT</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('thermal', this)" id="btn-thermal"><i class="fas fa-fire"></i></div><div class="menu-label">NEG</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('urbex', this)" id="btn-urbex"><i class="fas fa-city"></i></div><div class="menu-label">URBEX</div></div>
            
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('sls', this)" id="btn-sls"><i class="fas fa-ghost"></i></div><div class="menu-label">SLS</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('lidar', this)" id="btn-heatmap"><i class="fas fa-fingerprint"></i></div><div class="menu-label">LIDAR</div></div>
        </div>
        <div id="menu-right" class="menu-container right-side">
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="togglePareidolia(this)" id="btn-ia"><i class="fas fa-eye"></i></div><div class="menu-label">VISION</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="openConnect()"><i class="fas fa-link"></i></div><div class="menu-label">LINK</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="resetZoom(this)"><i class="fas fa-compress"></i></div><div class="menu-label">RESET</div></div>
        </div>
    </div>

    <div id="loading">
        <img src="obr-logo.png" class="w-24 h-24 object-contain mb-4 animate-pulse drop-shadow-[0_0_20px_rgba(220,38,38,0.5)]">
        <h1 class="text-3xl text-red-600 font-bold mb-1 tracking-widest font-orbitron">OBR CAM</h1>
        <p class="text-xs font-mono text-gray-500 mb-8">LIDAR v6.1.5 (SENSOR FIX)</p>
        <div class="w-64 h-1 bg-gray-800 rounded overflow-hidden"><div id="progress-bar"></div></div>
        <div id="progress-text" class="mt-2 text-xs font-mono text-red-500">CARGANDO...</div>
        <button class="mt-8 px-8 py-3 bg-red-900/20 border border-red-600 text-red-500 font-bold font-orbitron rounded hover:bg-red-900/50 transition load-btn" onclick="initApp()">INICIAR C√ÅMARA</button>
    </div>

    <div id="connect-modal" class="modal-bg">
        <div class="bg-neutral-900 border border-cyan-500 p-8 rounded-lg w-80 text-center shadow-[0_0_30px_rgba(0,255,255,0.1)]">
            <h3 class="text-cyan-400 mb-4 text-xl tracking-widest font-bold">CONECTAR A ESTUDIO</h3>
            <input type="text" id="stream-name" placeholder="NOMBRE (EJ: cam1)" class="w-full bg-black border border-gray-700 text-white p-3 text-center uppercase mb-4 text-lg outline-none focus:border-cyan-400 rounded" value="cam1">
            <button onclick="startHybridTransmission()" class="w-full bg-cyan-900 text-white font-bold py-3 hover:bg-cyan-700 mb-3 rounded font-orbitron">ENLAZAR</button>
            <button onclick="document.getElementById('connect-modal').classList.remove('active')" class="text-gray-500 text-xs hover:text-white">CANCELAR</button>
        </div>
    </div>

    <!-- MODAL DE CONFIGURACI√ìN UNIFICADO (2 COLUMNAS) -->
    <div id="settings-modal" class="modal-bg">
        <div class="relative bg-neutral-900 border border-red-900 p-6 rounded w-[480px] max-w-[95%] shadow-[0_0_30px_rgba(255,0,0,0.1)]">
            <!-- BOT√ìN X DE CIERRE -->
            <button onclick="document.getElementById('settings-modal').classList.remove('active')" class="absolute top-3 right-3 text-gray-600 hover:text-red-500 transition-colors">
                <i class="fas fa-times text-xl"></i>
            </button>

            <h2 class="text-red-500 font-orbitron mb-4 font-bold text-center uppercase tracking-widest text-lg">CONFIGURACI√ìN SISTEMA</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <!-- COLUMNA 1: RED -->
                <div class="bg-black/50 p-3 rounded border border-gray-800">
                    <h3 className="text-xs font-bold text-gray-400 mb-2 border-b border-gray-700 pb-1">RED ESTUDIO</h3>
                    <label class="text-[9px] text-gray-500 font-mono mb-1 block uppercase">DOCK ID / IP</label>
                    <input type="text" id="mtx-host" placeholder="EJ: 192.168.1.50" class="w-full bg-black border border-gray-700 p-2 text-white text-xs rounded font-mono outline-none focus:border-red-500 text-center mb-2">
                    <p class="text-[8px] text-gray-600 font-mono uppercase text-center leading-tight">IP SE CONVIERTE A ID AUTO</p>
                </div>

                <!-- COLUMNA 2: IA -->
                <div class="bg-black/50 p-3 rounded border border-gray-800">
                    <h3 className="text-xs font-bold text-gray-400 mb-2 border-b border-gray-700 pb-1">IA ANALYZER</h3>
                    <label class="text-[9px] text-gray-500 font-mono mb-1 block">API KEY</label>
                    
                    <!-- INPUT CON BOT√ìN EMBEBIDO -->
                    <div class="relative w-full mb-2">
                        <input type="password" id="api-key-internal" placeholder="GEMINI KEY" class="w-full bg-black border border-gray-700 p-2 pr-10 text-white text-xs rounded outline-none focus:border-red-500">
                        <button onclick="window.open('https://aistudio.google.com/api-keys', '_blank')" class="absolute right-2 top-1/2 -translate-y-1/2 text-base hover:scale-110 transition-transform leading-none" title="Crear API Key">
                            üì≤
                        </button>
                    </div>

                    <button id="btn-validate-api" onclick="validateAndSaveKey()" class="w-full border border-green-800 text-green-500 hover:bg-green-900/30 py-1 rounded text-[10px] font-bold">VALIDAR KEY</button>
                    <div id="api-status-msg" class="text-[9px] font-mono mt-1 text-center text-yellow-500 h-3"></div>
                </div>
            </div>

            <div class="h-px bg-gray-800 w-full mb-4"></div>
            
            <button onclick="saveSettings()" class="w-full bg-red-900/20 border border-red-600 text-red-500 hover:bg-red-900/50 hover:text-white py-3 rounded text-sm font-bold uppercase tracking-widest transition-colors font-orbitron">GUARDAR Y CERRAR</button>
        </div>
    </div>

<script>
    const AI_SENSITIVITY = 0.2; 
    const state = { 
        apiKey: localStorage.getItem("obr_gemini_key") || "", 
        aiModel: localStorage.getItem("obr_ai_model") || "gemini-2.5-flash-preview-09-2025", 
        studioId: localStorage.getItem("obr_studio_id") || "",
        filter: 'normal', 
        isSLS: false, 
        isLidar: false, 
        isPareidolia: false, 
        zoom: 1 
    };
    
    const PEER_CONFIG = {
        config: {
            iceServers: [
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        }
    };
    
    // Globals
    let GEMINI_API_KEY = state.apiKey;
    let CURRENT_AI_MODEL = state.aiModel;
    let isAIProcessing = false;
    let isPareidoliaActive = false;
    let pareidoliaInterval = null;
    let scanInterval = null;
    let lastPareidoliaCall = 0; 
    let imageCollapseTimeout = null;

    // VARIABLES BURN-IN IA
    let currentAiText = "";
    let currentAiImage = null; // NUEVO: Imagen IA
    let aiTextTimer = null;
    let radarAngle = 0; // Para animaci√≥n de radar
    let canvasScanBoxes = []; // <--- NUEVO ARRAY PARA CANVAS

    // ESTADO PARA TEXTO CICLICO
    let aiScannerState = 0; // 0=SEARCH, 1=RAW, 2=SENSORS
    let aiScannerTimer = 0;

    // SISTEMA DE ANIMACI√ìN F√çSICA (Spring Physics)
    const animState = {
        hudScale: 1.0,
        hudTarget: 1.0,
        aiScale: 0.0,
        aiTarget: 0.0
    };

    const el = { video: document.getElementById('shared-video-element'), canvas: document.getElementById('sls-canvas'), heatCanvas: document.getElementById('heatmap-buffer'), lidarCanvas: document.getElementById('lidar-buffer'), zoom: document.getElementById('zoom-container'), statusText: document.getElementById('status-text'), statusDot: document.getElementById('status-dot') };

    const ctx = el.canvas.getContext('2d', { alpha: true, desynchronized: true });
    const lidarCtx = el.lidarCanvas.getContext('2d', { alpha: true });
    const aiCanvas = document.createElement('canvas'); aiCanvas.width = 320; aiCanvas.height = 180;
    const aiCtx = aiCanvas.getContext('2d', { willReadFrequently: true });

    let aiDetector = null, faceMesh = null, segmenter = null, poses = [], faces = [], lidarMask = null;
    let lidarBusy = false; 
    let lastLidarMask = null; 
    
    let videoStream, peerCommand = null, peerVideoSender = null, conn = null;
    let frameCount = 0, lastTime = performance.now(), currentFps = 0;

    let logoImg = new Image(); logoImg.src = 'obr-logo.png';

    window.onload = () => { 
        document.getElementById('api-key-internal').value = state.apiKey; 
        document.getElementById('mtx-host').value = state.studioId; 
        initSystemMonitors(); // Init ASAP
    };

    document.addEventListener("DOMContentLoaded", () => {
        initSystemMonitors(); // Init on DOM Ready
    });
    
    // --- NUEVO: FUNCIONES DE MONITORIZACI√ìN DE SISTEMA REFORZADAS ---
    function initSystemMonitors() {
        const baseClasses = "flex items-center gap-2 bg-black/60 border px-3 py-1 rounded-full text-[10px] font-mono backdrop-blur-sm transition-colors duration-300";

        // 1. MONITOR DE BATER√çA (API Real)
        const batEl = document.getElementById('battery-indicator');
        const batTxt = document.getElementById('battery-level');
        const batIcon = document.getElementById('battery-icon');

        if ('getBattery' in navigator) {
            navigator.getBattery().then(function(battery) {
                function updateBattery() {
                    if (!batEl) return;
                    
                    const level = Math.round(battery.level * 100);
                    const charging = battery.charging;
                    
                    batEl.classList.remove('hidden');
                    batTxt.innerText = level + '%';
                    
                    // Resetear clases base para evitar conflictos
                    batEl.className = baseClasses;
                    batIcon.className = 'fas'; // Reset icono
                    
                    if (charging) {
                        batIcon.classList.add('fa-bolt');
                        batEl.classList.add('text-yellow-400', 'border-yellow-600');
                    } else {
                        if (level > 80) {
                            batIcon.classList.add('fa-battery-full');
                            batEl.classList.add('text-green-400', 'border-green-800');
                        } else if (level > 60) {
                            batIcon.classList.add('fa-battery-three-quarters');
                            batEl.classList.add('text-green-400', 'border-green-800');
                        } else if (level > 40) {
                            batIcon.classList.add('fa-battery-half');
                            batEl.classList.add('text-gray-400', 'border-gray-700');
                        } else if (level > 20) {
                            batIcon.classList.add('fa-battery-quarter');
                            batEl.classList.add('text-yellow-500', 'border-yellow-700');
                        } else {
                            batIcon.classList.add('fa-battery-empty');
                            batEl.classList.add('text-red-500', 'border-red-600', 'animate-pulse');
                        }
                    }
                }
                updateBattery();
                battery.addEventListener('levelchange', updateBattery);
                battery.addEventListener('chargingchange', updateBattery);
            }).catch(e => console.log("Battery API Error:", e));
        }

        // 2. MONITOR DE RED (API Real - Chrome/Android)
        const netEl = document.getElementById('network-indicator');
        const netTxt = document.getElementById('network-type');
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

        if (connection && netEl) {
            function updateNetwork() {
                // Tipo efectivo: '4g', '3g', '2g', 'slow-2g'
                const type = connection.effectiveType ? connection.effectiveType.toUpperCase() : '4G';
                
                netEl.classList.remove('hidden');
                netTxt.innerText = type;
                
                // Reset clases
                netEl.className = baseClasses;
                
                if (type === '4G') netEl.classList.add('text-green-400', 'border-green-800');
                else if (type === '3G') netEl.classList.add('text-yellow-400', 'border-yellow-700');
                else if (type === '2G' || type === 'SLOW-2G') netEl.classList.add('text-red-500', 'border-red-600');
                else netEl.classList.add('text-gray-400', 'border-gray-700');
            }
            
            updateNetwork();
            connection.addEventListener('change', updateNetwork);
        }
    }

    async function initApp() {
        document.querySelector('.load-btn').style.display = 'none';
        initSystemMonitors(); // INTENTO EXTRA AL INICIAR APP
        try {
            updateProgress(10, "INICIANDO SENSOR...");
            const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true }, video: { facingMode: 'environment', width: 1280, height: 720, frameRate: 30 } });
            videoStream = stream; el.video.srcObject = stream; el.video.play();
        } catch(e) {
            alert("Error Cr√≠tico C√°mara: " + e.message);
            return; 
        }
        updateProgress(100, "VIDEO OK");
        document.getElementById('loading').style.display = 'none';
        resize(); window.addEventListener('resize', resize);
        requestAnimationFrame(renderLoop);
        setInterval(telemetryLoop, 1000);
        showToast("Cargando Motores IA...", false);
        setTimeout(async () => {
            try {
                if(window.tf) { 
                    try { 
                        await tf.setBackend('webgl'); 
                    } catch(e) { await tf.setBackend('cpu'); } 
                }
                
                if(window.poseDetection) { 
                    try { 
                        aiDetector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, { 
                            modelType: poseDetection.movenet.modelType.MULTIPOSE_LIGHTNING 
                        }); 
                    } catch(e) {} 
                }
                
                if(window.FaceMesh) { try { faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`}); faceMesh.setOptions({ maxNumFaces: 3, minDetectionConfidence: AI_SENSITIVITY }); faceMesh.onResults(res => { faces = res.multiFaceLandmarks || []; }); await faceMesh.initialize(); } catch(e) {} }
                
                if(window.SelfieSegmentation) { 
                    try { 
                        const selfieSegmentation = new SelfieSegmentation({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`}); 
                        selfieSegmentation.setOptions({ modelSelection: 1 }); // 1 = Landscape
                        selfieSegmentation.onResults(res => { 
                            if(res && res.segmentationMask) {
                                lidarMask = res.segmentationMask; 
                                lastLidarMask = res.segmentationMask; 
                            }
                            lidarBusy = false;
                        }); 
                        segmenter = selfieSegmentation; 
                    } catch(e) {} 
                }
                
                showToast("SISTEMAS IA ACTIVOS", false);
                setInterval(aiLoop, 80); 
            } catch(globalErr) { console.error("Error Global IA:", globalErr); showToast("IA: Carga Parcial (Cam OK)", true); }
        }, 500); 
    }

    function onLidarResults(results) { if(results && results.segmentationMask) lidarMask = results.segmentationMask; }
    
    function drawLidarEffect(c, width, height) {
        const maskToUse = lidarMask || lastLidarMask; 
        if (!maskToUse) return; 
        
        lidarCtx.clearRect(0, 0, width, height);
        lidarCtx.save();
        lidarCtx.drawImage(maskToUse, 0, 0, width, height);
        lidarCtx.globalCompositeOperation = 'source-in';
        const grad = lidarCtx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, 'rgba(255, 0, 0, 0.9)'); grad.addColorStop(0.5, 'rgba(255, 255, 0, 0.8)'); grad.addColorStop(1, 'rgba(0, 0, 255, 0.8)');
        lidarCtx.fillStyle = grad; lidarCtx.fillRect(0, 0, width, height);
        lidarCtx.restore();
        c.globalCompositeOperation = 'screen'; c.drawImage(el.lidarCanvas, 0, 0, width, height); c.globalCompositeOperation = 'source-over';
    }

    function resize() { el.canvas.width = window.innerWidth; el.canvas.height = window.innerHeight; el.lidarCanvas.width = window.innerWidth; el.lidarCanvas.height = window.innerHeight; }
    function updateProgress(p, t) { document.getElementById('progress-bar').style.width = p + '%'; document.getElementById('progress-text').innerText = t; }

    function drawBurnInHUD(ctx, width, height, scale) {
        if(scale <= 0.01) return;

        ctx.save();
        const centerX = 20 + 80; 
        const centerY = 20 + 20; 
        ctx.translate(centerX, centerY);
        ctx.scale(scale, scale);
        ctx.translate(-centerX, -centerY);

        ctx.shadowColor = "black"; ctx.shadowBlur = 4;
        if(logoImg.complete) ctx.drawImage(logoImg, 20, 20, 40, 40);
        ctx.fillStyle = "white"; ctx.font = "bold 16px 'Orbitron', sans-serif";
        ctx.fillText("EXPLORACIONES OBR", 70, 40);
        const now = new Date();
        ctx.fillStyle = "#ff3333"; ctx.font = "12px 'Share Tech Mono', monospace";
        ctx.fillText(now.toLocaleDateString() + " - " + now.toLocaleTimeString(), 70, 58);
        
        if(state.isSLS) {
            const bx = width/2 - 40;
            ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(bx, 20, 80, 20);
            ctx.strokeStyle = "#d946ef"; ctx.lineWidth = 1; ctx.strokeRect(bx, 20, 80, 20);
            ctx.fillStyle = "#d946ef"; ctx.font = "10px monospace"; ctx.fillText("‚óè SLS ACTIVO", bx + 5, 33);
        }
        ctx.restore();
    }

    // FUNCI√ìN AUXILIAR PARA TEXTO GLITCH
    function drawGlitchText(c, text, x, y, size = 12) {
        const glitchOffset = Math.random() * 4 - 2;
        c.font = `bold ${size}px 'Share Tech Mono'`;
        c.fillStyle = "rgba(255, 0, 0, 0.7)"; 
        c.fillText(text, x + glitchOffset, y);
        c.fillStyle = "rgba(0, 255, 255, 0.7)"; 
        c.fillText(text, x - glitchOffset, y);
        c.fillStyle = "#ffffff"; 
        c.fillText(text, x, y);
    }
    
    // --- NUEVA FUNCI√ìN PARA DIBUJAR CUADROS DE ESCANEO EN CANVAS ---
    function drawCanvasScanBoxes(c, w, h) {
        const now = Date.now();
        canvasScanBoxes = canvasScanBoxes.filter(box => now - box.startTime < 800);
        canvasScanBoxes.forEach(box => {
            const age = now - box.startTime;
            const alpha = 1 - (age / 800);
            const scale = 1.3 - (age / 800) * 0.5;
            c.save();
            c.translate(box.x + box.size/2, box.y + box.size/2);
            c.scale(scale, scale);
            c.translate(-(box.x + box.size/2), -(box.y + box.size/2));
            c.strokeStyle = `rgba(255, 0, 0, ${alpha * 0.9})`;
            c.lineWidth = 2;
            c.strokeRect(box.x, box.y, box.size, box.size);
            c.shadowBlur = 10; c.shadowColor = `rgba(255, 0, 0, ${alpha * 0.6})`;
            c.strokeRect(box.x, box.y, box.size, box.size);
            c.restore();
        });
    }

    function drawAIBurnIn(c, w, h, scale) {
        if(scale <= 0.01) return;

        c.save();
        
        const bx = 20, by = 20; 
        const panelW = 220; 
        
        let displayTxt = currentAiText;
        let isScanning = !currentAiImage; // Si no hay imagen, estamos escaneando
        
        // --- L√ìGICA DE ESTADO C√çCLICO PARA EL TEXTO ---
        if (isScanning && !displayTxt) {
             aiScannerTimer++;
             if(aiScannerTimer > 150) { // Cambia cada ~2.5 segundos (60fps)
                 aiScannerState = (aiScannerState + 1) % 3;
                 aiScannerTimer = 0;
             }
             
             if(aiScannerState === 0) displayTxt = "Analizando Entorno...";
             else if(aiScannerState === 1) displayTxt = `raw data: 0x${Math.floor(Math.random()*16777215).toString(16)}`;
             else if(aiScannerState === 2) displayTxt = "sensores:\n  lidar: on\n  temp: 14c\n  prox: 98%";
        }
        
        let borderColor = isScanning ? "#ff0000" : "#ff3333";
        // REGLA: SI ESCANEA, FONDO TRANSPARENTE. SI HAY RESULTADO, FONDO OPACO.
        let bgColor = isScanning ? "rgba(0,0,0,0)" : "rgba(10, 0, 0, 0.90)"; 
        
        // Calcular altura imagen (o altura del esc√°ner simulado)
        let imgH = 0;
        if (isScanning) {
            imgH = 150; 
        } else if(currentAiImage && currentAiImage.complete && currentAiImage.naturalWidth > 0) {
             imgH = panelW * (currentAiImage.naturalHeight / currentAiImage.naturalWidth);
        }

        // ANIMACI√ìN POP
        const centerX = bx + panelW/2;
        const centerY = by + imgH/2 + 20; 
        c.translate(centerX, centerY);
        c.scale(scale, scale);
        c.translate(-centerX, -centerY);

        // REGLA: SI ESCANEA, NO DIBUJAR CAJA PRINCIPAL
        if (!isScanning) {
            let txtH = 40; // Approx
            const totalH = imgH + txtH;
            
            c.fillStyle = bgColor; 
            c.fillRect(bx, by, panelW, totalH);
            c.fillStyle = borderColor;
            c.fillRect(bx, by, 4, totalH);
        }

        // DIBUJAR VISUALIZACI√ìN (IMAGEN O RADAR)
        if(imgH > 0) {
            if (isScanning) {
                // --- NUEVO RADAR "TACTICAL PULSE" (2 Aspas + Respiraci√≥n) ---
                c.save();
                
                const radarRadiusBase = 50;
                const radarCx = bx + radarRadiusBase + 10;
                const radarCy = by + radarRadiusBase + 10;
                
                c.translate(radarCx, radarCy);
                
                // 1. FONDO MALLA CIRCULAR (EST√ÅTICA/WIREFRAME)
                // Usamos un cian/verde muy transparente para simular pantalla
                c.strokeStyle = "rgba(0, 255, 100, 0.15)"; 
                c.lineWidth = 1;
                
                // Anillos conc√©ntricos
                for(let r=10; r<=radarRadiusBase; r+=10) {
                    c.beginPath(); c.arc(0, 0, r, 0, Math.PI * 2); c.stroke();
                }
                // Mira en cruz
                c.beginPath(); c.moveTo(-radarRadiusBase, 0); c.lineTo(radarRadiusBase, 0); c.stroke();
                c.beginPath(); c.moveTo(0, -radarRadiusBase); c.lineTo(0, radarRadiusBase); c.stroke();

                // 2. DIN√ÅMICA DE RESPIRACI√ìN (PULSE)
                // Usamos el tiempo para crear una onda senoidal suave
                const pulse = (Math.sin(performance.now() * 0.003) + 1) / 2; // Va de 0 a 1 suavemente
                const currentRadius = radarRadiusBase * (0.6 + (pulse * 0.4)); // Radio oscila entre 60% y 100%

                // 3. ASPAS GIRATORIAS (HELICE DE 2 HOJAS)
                radarAngle += 0.04; 
                c.rotate(radarAngle);

                const drawBlade = (angleOffset) => {
                    c.save();
                    c.rotate(angleOffset);
                    
                    c.beginPath();
                    c.moveTo(0,0);
                    c.arc(0, 0, currentRadius, -0.4, 0.4); // Cono de ~45 grados
                    c.lineTo(0,0);
                    
                    // GRADIENTE DIN√ÅMICO (CAMBIA SEG√öN EL TAMA√ëO)
                    const grad = c.createRadialGradient(0, 0, 0, 0, 0, currentRadius);
                    grad.addColorStop(0, "rgba(0,0,0,0)"); // Centro transparente
                    
                    if (pulse > 0.7) {
                        // GRANDE = PELIGRO (ROJO)
                        grad.addColorStop(0.5, "rgba(255, 100, 0, 0.3)"); // Naranja
                        grad.addColorStop(1, "rgba(255, 0, 0, 0.6)"); // Rojo
                    } else {
                        // PEQUE√ëO = SEGURO (VERDE/AMARILLO)
                        grad.addColorStop(0.5, "rgba(0, 150, 0, 0.3)"); // Verde
                        grad.addColorStop(1, "rgba(200, 200, 0, 0.5)"); // Amarillo
                    }
                    
                    c.fillStyle = grad;
                    c.fill();
                    c.restore();
                };

                // DIBUJAR LAS 2 ASPAS "ENCONTRADAS" (OPUESTAS 180 GRADOS)
                drawBlade(0);          // Aspa 1
                drawBlade(Math.PI);    // Aspa 2 (Opuesta)

                c.restore();

                // TEXTO DE ESTADO AL LADO DERECHO DEL RADAR (ASIM√âTRICO)
                const txtX = radarCx + radarRadiusBase + 15;
                const txtY = radarCy; 

                if (displayTxt.includes('\n')) {
                    const lines = displayTxt.split('\n');
                    let lineY = txtY - 15;
                    lines.forEach((l, idx) => {
                        drawGlitchText(c, l.toLowerCase(), txtX, lineY + (idx*14), 11);
                    });
                } else {
                    drawGlitchText(c, displayTxt.toLowerCase(), txtX, txtY + 5, 12);
                }

            } else {
                // --- IMAGEN REAL RESULTANTE ---
                c.save();
                c.filter = "invert(100%) grayscale(100%) contrast(1.5)";
                c.drawImage(currentAiImage, bx, by, panelW, imgH);
                c.restore(); 
                c.strokeStyle = borderColor;
                c.lineWidth = 1;
                c.strokeRect(bx, by, panelW, imgH);
                
                // Texto de resultado
                c.fillStyle = "#ffcccc";
                c.font = "10px 'Share Tech Mono'";
                let line = '';
                let ly = by + imgH + 20;
                
                const resWords = currentAiText ? currentAiText.split(' ') : [];
                 for(let n = 0; n < resWords.length; n++) {
                    let testLine = line + resWords[n] + ' ';
                    if (c.measureText(testLine).width > (panelW - 20) && n > 0) {
                        c.fillText(line.toLowerCase(), bx + 10, ly); 
                        line = resWords[n] + ' ';
                        ly += 14;
                    } else {
                        line = testLine;
                    }
                }
                c.fillText(line.toLowerCase(), bx + 10, ly);
            }
        }

        c.restore();
    }

    function renderLoop() {
        frameCount++;
        
        const vW = el.video.videoWidth, vH = el.video.videoHeight;
        const cW = el.canvas.width, cH = el.canvas.height;
        
        ctx.save();
        ctx.clearRect(0, 0, cW, cH);
        
        // --- APLICACI√ìN DE FILTROS H√çBRIDA v6.1.1 ---
        // 1. REPLICA DE CSS EN CANVAS (Para que el Stream salga procesado)
        if(state.filter === 'night') {
            ctx.filter = 'grayscale(100%) sepia(100%) hue-rotate(90deg) saturate(2.0) contrast(1.2) brightness(1.0)';
        } else if(state.filter === 'thermal') {
            ctx.filter = 'grayscale(75%) invert(75%) contrast(1.7) brightness(0.8)';
        } else if(state.filter === 'urbex') {
            ctx.filter = 'sepia(100%) hue-rotate(-20deg) saturate(2.5) contrast(1.3) brightness(0.7)';
        } else {
            ctx.filter = 'none';
        }
        
        if (vW && vH) {
            const vRatio = vW / vH, cRatio = cW / cH;
            let dW, dH, dX, dY;
            if (cRatio > vRatio) { dW = cW; dH = cW / vRatio; dX = 0; dY = (cH - dH) / 2; } 
            else { dW = cH * vRatio; dH = cH; dX = (cW - dW) / 2; dY = 0; }
            
            // DIBUJAR VIDEO EN CANVAS (Para Stream)
            // Aunque localmente el Canvas est√© oculto (opacity: 0), aqu√≠ se dibuja para el captureStream()
            ctx.drawImage(el.video, 0, 0, vW, vH, dX, dY, dW, dH);
            window.drawCoords = { dW, dH, dX, dY, vW, vH };
            
            ctx.filter = 'none'; 
            
            // --- EFECTO SCANLINES EN CANVAS (Para Stream) ---
            if(state.filter === 'night') {
                ctx.fillStyle = 'rgba(0, 30, 0, 0.2)'; 
                for(let i=0; i<cH; i+=3) { ctx.fillRect(0, i, cW, 1); }
            }
            if (state.isLidar) { ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fillRect(0,0, cW, cH); drawLidarEffect(ctx, cW, cH); }
        }
        
        ctx.restore(); 

        if (state.isSLS && !state.isLidar) drawSLS();
        
        // --- LOGICA DE ANIMACI√ìN (WATER POP) ---
        const speed = 0.4;
        animState.hudScale += (animState.hudTarget - animState.hudScale) * speed;
        animState.aiScale += (animState.aiTarget - animState.aiScale) * speed;

        drawBurnInHUD(ctx, cW, cH, animState.hudScale);

        // QUEMADO DE CUADROS ROJOS EN CANVAS
        if (state.isPareidolia) drawCanvasScanBoxes(ctx, cW, cH);
        
        // SOLO DIBUJAR IA SI EL TARGET ES > 0 (Est√° activo)
        if (animState.aiTarget > 0.01 || animState.aiScale > 0.01) {
            drawAIBurnIn(ctx, cW, cH, animState.aiScale);
        }

        requestAnimationFrame(renderLoop);
    }

    async function aiLoop() {
        if (isAIProcessing) return; 
        if (!state.isSLS && !state.isLidar && !state.isPareidolia) { 
            poses = []; faces = []; lidarMask = null; return; 
        }

        if (state.isLidar && segmenter) { 
            if(!lidarBusy) { 
                lidarBusy = true; 
                try { await segmenter.send({image: el.video}); } catch(e){ lidarBusy = false; } 
            } 
        } else {
            aiCtx.drawImage(el.video, 0, 0, aiCanvas.width, aiCanvas.height);
            
            if (aiDetector && state.isSLS) { 
                try { 
                    poses = await aiDetector.estimatePoses(aiCanvas, {
                        maxPoses: 5, 
                        flipHorizontal: false,
                        scoreThreshold: 0.25 
                    }); 
                } catch(e){} 
            }
            if (faceMesh && state.isSLS) { 
                try { await faceMesh.send({image: el.video}); } catch(e){} 
            }
        }
    }

    function drawSLS() {
        if (!window.drawCoords) return;
        const { dW, dH, dX, dY } = window.drawCoords;
        const mapX = (x) => (x / aiCanvas.width) * dW + dX; const mapY = (y) => (y / aiCanvas.height) * dH + dY;
        ctx.strokeStyle = '#d946ef'; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.fillStyle = '#a855f7';
        
        poses.forEach(pose => {
            const k = pose.keypoints;
            const bodyPairs = [[5,7],[7,9],[6,8],[8,10],[11,12],[11,13],[13,15],[12,14],[14,16],[5,11],[6,12]];
            ctx.beginPath(); bodyPairs.forEach(([i, j]) => { if(k[i].score > AI_SENSITIVITY && k[j].score > AI_SENSITIVITY) { ctx.moveTo(mapX(k[i].x), mapY(k[i].y)); ctx.lineTo(mapX(k[j].x), mapY(k[j].y)); } }); ctx.stroke();
            const nose = k[0], lEye = k[1], rEye = k[2], lShoulder = k[5], rShoulder = k[6];
            let neckX, neckY;
            if(lShoulder.score > AI_SENSITIVITY && rShoulder.score > AI_SENSITIVITY) {
                neckX = (mapX(lShoulder.x) + mapX(rShoulder.x)) / 2; neckY = (mapY(lShoulder.y) + mapY(rShoulder.y)) / 2;
                ctx.beginPath(); ctx.moveTo(mapX(lShoulder.x), mapY(lShoulder.y)); ctx.lineTo(neckX, neckY); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(mapX(rShoulder.x), mapY(rShoulder.y)); ctx.lineTo(neckX, neckY); ctx.stroke();
                if(nose.score > AI_SENSITIVITY) { ctx.beginPath(); ctx.moveTo(mapX(nose.x), mapY(nose.y)); ctx.lineTo(neckX, neckY); ctx.stroke(); }
            }
            if(nose.score > AI_SENSITIVITY) { if(lEye.score > AI_SENSITIVITY) { ctx.beginPath(); ctx.moveTo(mapX(lEye.x), mapY(lEye.y)); ctx.lineTo(mapX(nose.x), mapY(nose.y)); ctx.stroke(); } if(rEye.score > AI_SENSITIVITY) { ctx.beginPath(); ctx.moveTo(mapX(rEye.x), mapY(rEye.y)); ctx.lineTo(mapX(nose.x), mapY(nose.y)); ctx.stroke(); } }
            k.forEach((p, i) => { if(i === 3 || i === 4) return; if(p.score > AI_SENSITIVITY) { ctx.beginPath(); ctx.arc(mapX(p.x), mapY(p.y), 4, 0, 2*Math.PI); ctx.fill(); } });
        });
        if(faces.length > 0) {
            faces.forEach(face => {
                let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                face.forEach((pt) => { const x=pt.x*dW+dX; const y=pt.y*dH+dY; if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; });
                const pad=20; ctx.strokeStyle='red'; ctx.lineWidth=2; ctx.strokeRect(minX-pad, minY-pad, (maxX-minX)+pad*2, (maxY-minY)+pad*2);
                ctx.fillStyle='#39ff14'; face.forEach((pt) => { ctx.fillRect(pt.x*dW+dX, pt.y*dH+dY, 1.5, 1.5); });
            });
        }
    }

    function updateClock() {
        const now = new Date(); const dateStr = now.toLocaleDateString('es-ES', {day: '2-digit', month: '2-digit', year: 'numeric'}); const timeStr = now.toLocaleTimeString();
        const clockEl = document.getElementById('hud-time'); if (clockEl) clockEl.innerText = `${dateStr} - ${timeStr}`;
    }

    function telemetryLoop() {
        const now = performance.now(); const elapsed = now - lastTime;
        if (elapsed >= 1000) { currentFps = Math.round((frameCount * 1000) / elapsed); frameCount = 0; lastTime = now; }
        updateClock(); 
        let signal = 0; if(peerCommand && !peerCommand.disconnected && !peerCommand.destroyed) signal++; if(conn && conn.open) signal++; if(peerVideoSender && !peerVideoSender.disconnected) signal++;
        const vW = el.video.videoWidth || 0, vH = el.video.videoHeight || 0;
        document.getElementById('meta-res').innerText = `${vW}x${vH}`; document.getElementById('meta-fps').innerText = `${currentFps} FPS`;
        document.getElementById('signal-ui').className = `signal-bars signal-level-${signal}`;
        const statusEl = document.getElementById('status-text'), dotEl = document.getElementById('status-dot'), tallyEl = document.getElementById('tally-border');
        if(conn && conn.open) {
             statusEl.innerText = "ONLINE"; statusEl.className = "text-green-500 font-bold font-mono"; dotEl.className = "w-2 h-2 rounded-full bg-green-500 shadow-[0_0_10px_lime]"; tallyEl.className = "online";
        } else {
             statusEl.innerText = "PREVIEW"; statusEl.className = "text-gray-400 font-mono"; dotEl.className = "w-2 h-2 rounded-full bg-red-900"; tallyEl.className = "preview";
        }
    }

    function openConnect() { document.getElementById('connect-modal').classList.add('active'); }

    async function startHybridTransmission() {
        const name = document.getElementById('stream-name').value.trim(); if(!name) return;
        const fullId = state.studioId; 
        if(!fullId) { showToast("ID ESTUDIO VACIO", true); return; }
        
        document.getElementById('connect-modal').classList.remove('active'); showToast("Conectando...", false);
        
        // FIX TAILSCALE: Sanitizaci√≥n robusta
        let baseId = fullId.trim().replace(/\s+/g, ''); // Quitar espacios
        if (baseId.endsWith("-8889")) { baseId = baseId.slice(0, -5); }
        baseId = baseId.replace(/\./g, '-'); // Forzar guiones siempre
        
        const commandTarget = baseId;
        const videoTarget = baseId + "-8889";
        
        if(peerCommand) peerCommand.destroy();
        peerCommand = new Peer(null, PEER_CONFIG);
        
        peerCommand.on('open', () => {
            const connection = peerCommand.connect(commandTarget);
            
            connection.on('open', () => {
                conn = connection;
                conn.send({ type: 'register', name: name, hasAI: true });
                showToast("Enlace Comandos OK", false);
            });
            
            connection.on('data', handleCommand);
            connection.on('close', () => { showToast("Estudio desconectado", true); conn = null; });
            connection.on('error', (e) => { console.error("Data error", e); });
        });
        
        peerCommand.on('error', (err) => { console.error("PeerCMD Error:", err); showToast("Err CMD: " + err.type, true); });

        if(peerVideoSender) peerVideoSender.destroy();
        peerVideoSender = new Peer(null, PEER_CONFIG);
        
        peerVideoSender.on('open', () => {
            // TRANSMISI√ìN: Se usa el stream del canvas procesado
            const stream = el.canvas.captureStream(30); 
            const audioTracks = videoStream.getAudioTracks();
            if(audioTracks.length > 0) stream.addTrack(audioTracks[0]);
            
            // FIX: Retraso de seguridad para evitar "peer-unavailable" inmediato
            setTimeout(() => {
                const call = peerVideoSender.call(videoTarget, stream, { metadata: { name: name } });
                
                call.on('close', () => { console.log("Video call ended"); });
                call.on('error', (e) => { console.error("Video call error", e); });
                showToast("Transmitiendo Video...", false);
            }, 1500);
        });

        peerVideoSender.on('error', (err) => { console.error("PeerVID Error:", err); showToast("Err VID: " + err.type, true); });
    }

    function handleCommand(cmd) {
        showToast(`CMD: ${cmd.action?.toUpperCase() || cmd.type?.toUpperCase()}`);
        if(cmd.type === 'cmd' || cmd.category === 'cam') {
            const action = cmd.action;
            const value = cmd.value;
            if(action === 'filter') { 
                const map = { 'night':'btn-night', 'thermal':'btn-thermal', 'urbex':'btn-urbex', 'rad': 'btn-rad', 'sls':'btn-sls', 'lidar':'btn-heatmap', 'normal': null }; 
                setFilter(value, document.getElementById(map[value])); 
            }
            else if(action === 'flash') toggleTorch(value); 
            else if(action === 'toggle' && value === 'pareidolia') togglePareidolia();
            else if(action === 'reset') setFilter('normal', null);
        }
        else if (cmd.type === 'tally') {
            const tallyEl = document.getElementById('tally-border');
            if (cmd.state === 'program') { tallyEl.className = 'online'; }
            else if (cmd.state === 'preview') { tallyEl.className = 'preview'; }
            else { tallyEl.className = ''; }
        }
    }

    function setFilter(f, btn) {
        if(state.filter === f && f !== 'normal') f = 'normal'; state.filter = f; state.isSLS = (f === 'sls'); state.isLidar = (f === 'lidar');
        document.querySelectorAll('.menu-btn').forEach(b => b.classList.remove('active-state')); if(btn && f !== 'normal') btn.classList.add('active-state');
        document.body.className = ''; if(f !== 'normal') { if(f === 'night') document.body.classList.add('filter-night-vision'); else if(f === 'thermal') document.body.classList.add('filter-thermal'); else if(f === 'urbex') document.body.classList.add('filter-urbex'); else if(f === 'rad') document.body.classList.add('filter-rad'); else if(f === 'sls') document.body.classList.add('filter-pareidolia'); }
        
        // --- MODIFICACI√ìN SOLICITADA: FLASH AUTOM√ÅTICO EN MODO NEGATIVO (THERMAL) ---
        if(f === 'night' || f === 'thermal') toggleTorch(true); else toggleTorch(false); 
        
        document.getElementById('sls-pip').style.display = state.isSLS ? 'block' : 'none'; poses = []; lidarMask = null; lastLidarMask = null;
    }

    async function toggleTorch(force) { const t = videoStream?.getVideoTracks()[0]; if(!t) return; const on = (typeof force === 'boolean') ? force : !t.getSettings().torch; try { await t.applyConstraints({advanced:[{torch:on}]}); } catch(e){} }

    function speakText(text) {
        if('speechSynthesis' in window) {
            window.speechSynthesis.cancel(); const cleanText = text.replace(/[\.,;:-]{2,}/g, '. ').replace(/[\n\r]/g, ' ');
            const u = new SpeechSynthesisUtterance(cleanText); u.lang = 'es-MX'; u.rate = 1.0; u.pitch = 1.1; 
            const voices = window.speechSynthesis.getVoices();
            const femaleVoice = voices.find(v => v.lang.includes('es') && (v.name.includes('Paulina') || v.name.includes('Sabina') || v.name.includes('Mexico') || v.name.toLowerCase().includes('female')));
            if (femaleVoice) u.voice = femaleVoice; window.speechSynthesis.speak(u);
        }
    }

    function refreshAudioTracks() {
        if (!videoStream) return;
        // Hack para "despertar" el micr√≥fono si qued√≥ atenuado por el speech
        const tracks = videoStream.getAudioTracks();
        tracks.forEach(track => {
            track.enabled = false;
            setTimeout(() => { track.enabled = true; }, 50); // Breve reinicio
        });
    }

    function startScanningEffect() {
        const overlay = document.getElementById('ai-scan-overlay'); overlay.innerHTML = ''; overlay.style.display = 'block';
        
        // Limpiar intervalo previo si existe
        if (scanInterval) clearInterval(scanInterval);

        scanInterval = setInterval(() => {
            const box = document.createElement('div'); box.className = 'scan-box'; const size = Math.floor(Math.random() * 80) + 40;
            // REGLA: EXCLUIR LA ZONA SUPERIOR IZQUIERDA (DONDE EST√Å EL RADAR)
            // El radar ocupa aprox. 250x200 px desde la esquina (bx=20, by=20, w=220, h=var√≠a)
            let x, y;
            do {
                x = Math.floor(Math.random() * (window.innerWidth - size));
                y = Math.floor(Math.random() * (window.innerHeight - size));
            } while (x < 250 && y < 200); // Repetir si cae en la zona prohibida
            
            // --- NUEVO: GUARDAR COORDENADAS PARA CANVAS BURN-IN ---
            canvasScanBoxes.push({ x, y, size, startTime: Date.now() });

            box.style.width = `${size}px`; box.style.height = `${size}px`; box.style.left = `${x}px`; box.style.top = `${y}px`;
            overlay.appendChild(box); setTimeout(() => box.remove(), 800);
        }, 150); 
    }

    function stopScanningEffect() { 
        clearInterval(scanInterval); 
        const overlay = document.getElementById('ai-scan-overlay'); 
        overlay.innerHTML = ''; 
        overlay.style.display = 'none';
        canvasScanBoxes = []; // --- NUEVO: LIMPIAR CANVAS BURN-IN ---
    }

    async function triggerPareidolia() {
        const video = el.video; if(!GEMINI_API_KEY) return; if(isAIProcessing || window.speechSynthesis.speaking) return;
        const now = Date.now(); if (now - lastPareidoliaCall < 12000) return; lastPareidoliaCall = now;
        
        isAIProcessing = true; 
        
        // FEEDBACK INMEDIATO: MANTENER ESC√ÅNER VISUAL
        currentAiText = "b√∫squeda de se√±al..."; // Texto temporal en modo esc√°ner
        currentAiImage = null; // Nos aseguramos de que no hay imagen para que el HUD dibuje el radar
        
        // Los cuadros ya deber√≠an estar activos si isPareidoliaActive es true, 
        // pero por seguridad los reiniciamos/aseguramos aqu√≠
        startScanningEffect();

        const canvas = document.createElement('canvas'); canvas.width = 640; canvas.height = 360; canvas.getContext('2d').drawImage(video, 0, 0, 640, 360);
        
        // CAPTURAR IMAGEN (Pero solo mostrarla tras recibir respuesta para evitar "movimiento")
        const snapshot = new Image();
        snapshot.src = canvas.toDataURL('image/jpeg', 0.8);
        
        const base64 = canvas.toDataURL('image/jpeg', 0.6).split(',')[1];
        const prompt = "Act√∫a como un m√©dium digital. Describe en primera persona lo que ves. Usa frases como 'Veo...', 'Hay algo en...', 'Est√°...'. Busca caras en las sombras. S√© siniestro. Max 12 palabras.";
        try {
            let attempts = 0, success = false, data = null;
            while(attempts < 3 && !success) {
                try {
                    const modelToUse = CURRENT_AI_MODEL || "gemini-2.5-flash-preview-09-2025";
                    const resp = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelToUse}:generateContent?key=${GEMINI_API_KEY}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/jpeg", data: base64 } }] }] }) });
                    data = await resp.json(); if (data.candidates && data.candidates[0].content) success = true; else { attempts++; await new Promise(r => setTimeout(r, 1000)); }
                } catch(err) { attempts++; }
            }
            let text = success ? (data.candidates?.[0]?.content?.parts?.[0]?.text || "ANOMALIA DETECTADA").replace(/[*_]/g, '').trim() : "SE√ëAL DEBIL...";
            
            // --- RESULTADO OBTENIDO ---
            // Detenemos los cuadros rojos de la pantalla principal
            stopScanningEffect();
            
            // ACTUALIZACI√ìN IA: Mostrar imagen y texto
            currentAiText = text;
            currentAiImage = snapshot; // Ahora s√≠ mostramos la imagen est√°tica en el HUD
            
            clearTimeout(aiTextTimer);
            // TIEMPO EXTENDIDO: 9 SEGUNDOS DE VISIBILIDAD
            aiTextTimer = setTimeout(() => { 
                currentAiText = ""; 
                currentAiImage = null;
                
                // CRUCIAL: AL TERMINAR, SI LA IA SIGUE ACTIVA, VOLVER A ESCANEAR
                if (state.isPareidolia) {
                    startScanningEffect();
                }
            }, 9000);
            
            // NUEVO: Enviar texto al Estudio
            if (conn && conn.open) { conn.send({ type: 'ai-speech', text: text }); }
            
            speakText(text);
        } catch(e) { 
            isAIProcessing = false; 
            currentAiText = "error de se√±al"; 
            setTimeout(() => { 
                if(currentAiText === "error de se√±al") {
                    currentAiText = ""; 
                    // Si falla, volver a escanear tambi√©n
                    if (state.isPareidolia) startScanningEffect();
                }
            }, 3000);
        }
        isAIProcessing = false; 
    }

    function togglePareidolia(btnElement) {
        if(!GEMINI_API_KEY) { alert("NO API KEY: CONFIGURA EN AJUSTES"); return; }
        const btn = btnElement || document.getElementById('btn-ia'); isPareidoliaActive = !isPareidoliaActive; state.isPareidolia = isPareidoliaActive;
        const aiHeader = document.getElementById('ai-vision-header');
        
        if(isPareidoliaActive) {
            if(btn) btn.classList.add('active-state'); 
            document.body.classList.add('filter-pareidolia'); 
            speakText("VISI√ìN ACTIVADA"); 
            
            // CONTROL DE ANIMACI√ìN: SWAP HUD -> IA
            animState.hudTarget = 0.0;
            animState.aiTarget = 1.0;
            
            // LIMPIAR Y ACTIVAR ESC√ÅNER INMEDIATO
            currentAiText = "";
            currentAiImage = null;
            startScanningEffect(); // Activar visuales inmediatamente
            
            triggerPareidolia(); pareidoliaInterval = setInterval(triggerPareidolia, 12000);
        } else {
            // --- CORRECCI√ìN DE MICROFONO (Audio Ducking Fix) ---
            window.speechSynthesis.cancel(); // 1. Cancelar cualquier audio pendiente agresivamente
            refreshAudioTracks(); // 2. Refrescar tracks de audio para recuperar ganancia
            
            if(btn) btn.classList.remove('active-state'); 
            document.body.classList.remove('filter-pareidolia'); 
            speakText("VISI√ìN DESACTIVADA"); 
            
            // CONTROL DE ANIMACI√ìN: SWAP IA -> HUD
            animState.hudTarget = 1.0;
            animState.aiTarget = 0.0;

            clearInterval(pareidoliaInterval); isAIProcessing = false; stopScanningEffect(); 
            // NUEVO: Limpiar texto IA
            currentAiText = "";
            currentAiImage = null;
        }
        showMenus();
    }

    async function validateAndSaveKey() {
        const input = document.getElementById('api-key-internal'), btn = document.getElementById('btn-validate-api'), status = document.getElementById('api-status-msg'), k = input.value.trim();
        if(!k) { status.innerText = "‚ùå CAMPO VACIO"; return; }
        input.disabled = true; btn.disabled = true; const modelsToTry = ["gemini-2.5-flash-preview-09-2025", "gemini-1.5-flash", "gemini-1.5-pro"]; let workingModel = null;
        for(const step of ["CONECTANDO...", "ENVIANDO PING...", "VERIFICANDO..."]) { status.innerText = step; await new Promise(r => setTimeout(r, 400)); }
        for (const model of modelsToTry) { try { const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${k}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ contents: [{ parts: [{ text: "ping" }] }] }) }); if(response.ok) { workingModel = model; break; } } catch(e) {} }
        if(workingModel) {
            status.innerText = "‚úÖ ACTIVA (" + workingModel.replace("gemini-","").split("-")[0] + ")"; status.style.color = "#00ff41";
            GEMINI_API_KEY = k; CURRENT_AI_MODEL = workingModel; state.apiKey = k; state.aiModel = workingModel;
            localStorage.setItem('obr_gemini_key', k); localStorage.setItem('obr_ai_model', workingModel);
        } else { status.innerText = "‚ùå ERROR: LLAVE INVALIDA"; status.style.color = "red"; }
        input.disabled = false; btn.disabled = false;
    }

    function saveSettings() { 
        const rawIp = document.getElementById('mtx-host').value.trim();
        if(!rawIp) { showToast("Ingresa un ID v√°lido", true); return; }
        state.studioId = rawIp; 
        localStorage.setItem('obr_studio_id', state.studioId);
        showToast("Config Guardada"); 
        document.getElementById('settings-modal').classList.remove('active');
    }

    function openSettings() { document.getElementById('settings-modal').classList.add('active'); }
    
    let menuTimeout; const menus = [document.getElementById('menu-left'), document.getElementById('menu-right')];
    document.getElementById('touch-surface').addEventListener('click', showMenus);
    function showMenus() { menus.forEach(m => m.classList.add('visible')); clearTimeout(menuTimeout); menuTimeout = setTimeout(() => menus.forEach(m => m.classList.remove('visible')), 4000); }
    function showToast(msg, isError = false) { const t = document.createElement('div'); t.className = `toast ${isError ? 'error' : ''}`; t.innerText = msg; document.getElementById('toast-container').appendChild(t); setTimeout(() => t.remove(), 3000); }
    let pressTimer; const touchSurface = document.getElementById('touch-surface');
    touchSurface.addEventListener('pointerdown', (e) => { pressTimer = setTimeout(() => { state.zoom = state.zoom === 1 ? 2.5 : 1; const w = window.innerWidth, h = window.innerHeight, xPct = (e.clientX / w) * 100, yPct = (e.clientY / h) * 100; el.zoom.style.transformOrigin = `${xPct}% ${yPct}%`; el.zoom.style.transform = `scale(${state.zoom})`; const ind = document.getElementById('zoom-target-indicator'); ind.style.left = e.clientX+'px'; ind.style.top = e.clientY+'px'; ind.classList.add('active'); setTimeout(()=>ind.classList.remove('active'),500); if(navigator.vibrate) navigator.vibrate(50); }, 500); });
    touchSurface.addEventListener('pointerup', () => clearTimeout(pressTimer)); touchSurface.addEventListener('pointermove', () => clearTimeout(pressTimer));
    function resetZoom(btn) { state.zoom = 1; el.zoom.style.transform = `scale(1)`; if(btn) btn.classList.add('active-state'); setTimeout(()=>btn?.classList.remove('active-state'), 200); }
</script>
</body>
</html>
