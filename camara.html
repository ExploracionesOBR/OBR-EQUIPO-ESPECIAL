<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CAMARA OBR v213 (TAILSCALE READY)</title> 
    
    <link rel="icon" type="image/png" href="obr-logo.png">
    <link rel="apple-touch-icon" href="obr-logo.png">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LIBRERÍAS IA -->
    <script src="js/tf.min.js"></script>
    <script src="js/pose-detection.min.js"></script>
    <script src="js/face_mesh.js"></script>
    <script src="js/peerjs.min.js"></script>

    <script>
        if(!window.tf) document.write('<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"><\/script>');
        if(!window.poseDetection) document.write('<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"><\/script>');
        if(!window.FaceMesh) document.write('<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"><\/script>');
        if(!window.Peer) document.write('<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"><\/script>');
    </script>
    
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        * { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; box-sizing: border-box; outline: none; touch-action: none; }
        :root { --hud-primary: #ff3333; }
        body { background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; width: 100vw; height: 100vh; margin: 0; padding: 0; }
        
        #main-view-area { position: absolute; inset: 0; background: #000; overflow: hidden; }
        #zoom-container { position: absolute; inset: 0; width: 100%; height: 100%; transform-origin: center center; transition: transform 0.4s; will-change: transform; }
        
        #shared-video-element { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; opacity: 0; pointer-events: none; }
        
        #sls-canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: 2; pointer-events: none; }
        #heatmap-buffer { display: none; }

        /* ORIENTATION LOCK */
        #orientation-lock { position: fixed; inset: 0; z-index: 9999; background: #000; display: none; flex-direction: column; align-items: center; justify-content: center; color: white; text-align: center; }
        @media (orientation: portrait) { #orientation-lock { display: flex; } #ui-layer { display: none; } }

        /* FILTROS CSS */
        body.filter-night-vision #main-view-area::after { content: ""; position: absolute; inset: 0; pointer-events: none; background: radial-gradient(circle, rgba(50, 255, 50, 0.05) 50%, rgba(0,20,0,0.6) 95%); background-image: repeating-linear-gradient(0deg, rgba(0,0,0,0.1), rgba(0,0,0,0.1) 1px, transparent 1px, transparent 2px); z-index: 5; mix-blend-mode: overlay; }
        body.filter-urbex #main-view-area::after { content: ""; position: absolute; inset: 0; pointer-events: none; z-index: 5; box-shadow: inset 0 0 150px rgba(20,10,5,0.6); mix-blend-mode: multiply; }
        body.filter-heatmap #sls-canvas { filter: none; } 
        body.filter-pareidolia #main-view-area { border: 2px solid var(--hud-primary); }

        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 20; }
        .interactive { pointer-events: auto; }
        #tally-border { position: absolute; inset: 0; border: 0px solid transparent; transition: border-width 0.2s; z-index: 50; pointer-events: none; }
        #tally-border.program { border: 12px solid red; box-shadow: inset 0 0 40px red; }
        #tally-border.preview { border: 12px solid #00ff00; }
        
        /* HEADER (Ahora solo se usa para calcular posición, se dibuja en canvas) */
        #live-header-container { display: none; } 

        #ai-vision-header { position: absolute; top: 90px; left: 20px; display: flex; flex-direction: column; align-items: flex-start; opacity: 0; pointer-events: none; transition: opacity 0.5s; z-index: 60; width: 220px; }
        #ai-vision-header.active { opacity: 1; }
        #ai-mini-img { width: 100%; height: auto; border: 2px solid #ff3333; box-shadow: 0 0 25px rgba(255, 0, 0, 0.4); filter: invert(1) hue-rotate(180deg) contrast(1.5); margin-bottom: 0; background: black; display: block; }
        #ai-mini-text { width: 100%; background: rgba(10, 0, 0, 0.95); border: 1px solid #ff3333; border-top: none; border-left: 4px solid #ff3333; color: #ffcccc; font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; padding: 8px; text-align: left; text-transform: uppercase; box-shadow: 0 5px 15px rgba(0,0,0,0.8); text-shadow: 0 0 5px red; line-height: 1.2; }

        .menu-container { position: absolute; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 15px; z-index: 100; pointer-events: auto; transition: opacity 0.2s; opacity: 0; pointer-events: none; }
        .menu-container.visible { opacity: 1; pointer-events: auto; }
        .menu-container.left-side { left: 20px; }
        .menu-container.right-side { right: 20px; }
        .menu-btn { width: 50px; height: 50px; border: 2px solid var(--hud-primary); border-radius: 50%; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; color: var(--hud-primary); font-size: 1.2rem; cursor: pointer; backdrop-filter: blur(4px); box-shadow: 0 0 15px rgba(255, 51, 51, 0.3); transition: all 0.2s; }
        .menu-btn:active { transform: scale(0.9); }
        .menu-btn.active-state { background: white; border-color: white; color: black; box-shadow: 0 0 20px white; }
        .menu-label { font-size: 0.55rem; color: white; text-align: center; margin-top: 4px; font-family: 'Share Tech Mono'; text-shadow: 1px 1px 2px black; background: rgba(0,0,0,0.6); padding: 1px 4px; border-radius: 4px; }

        #loading { position: fixed; inset: 0; z-index: 200; background: black; display: flex; flex-direction: column; align-items: center; justify-content: center; background: radial-gradient(circle, #220000 0%, #000000 100%); }
        .load-btn { background: rgba(20,0,0,0.6); border: 2px solid var(--hud-primary); color: var(--hud-primary); padding: 18px 40px; font-size: 1.1rem; margin-top: 30px; cursor: pointer; font-weight: bold; clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px); transition: 0.2s; }
        
        #progress-container { width: 80%; max-width: 300px; height: 4px; background: #333; margin-top: 20px; border-radius: 2px; overflow: hidden; display: none; }
        #progress-bar { height: 100%; width: 0%; background: var(--hud-primary); transition: width 0.3s ease-out; box-shadow: 0 0 10px var(--hud-primary); }
        #progress-text { font-family: 'Share Tech Mono'; color: var(--hud-primary); font-size: 0.65rem; margin-top: 5px; min-height: 1.2em; text-align: center; white-space: pre-wrap; }

        .modal-bg { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 300; display: none; align-items: center; justify-content: center; pointer-events: auto; }
        .modal-bg.active { display: flex; }
        #touch-surface { position: absolute; inset: 0; z-index: 15; pointer-events: auto; }
        #sls-pip { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); color: var(--hud-primary); font-family: 'Share Tech Mono'; font-size: 0.8rem; display: none; text-shadow: 0 0 5px var(--hud-primary); background: rgba(0,0,0,0.6); padding: 2px 8px; border: 1px solid var(--hud-primary); border-radius: 4px; }
        #perf-stats { position: absolute; bottom: 5px; right: 5px; font-family: 'Share Tech Mono', monospace; font-size: 0.55rem; color: rgba(0, 255, 0, 0.6); background: rgba(0,0,0,0.4); padding: 2px 4px; border-radius: 4px; pointer-events: none; z-index: 80; text-align: right; }
        .signal-bars { display: inline-flex; align-items: flex-end; gap: 2px; height: 8px; margin-left: 5px; }
        .bar { width: 3px; background: #333; }
        .signal-good .bar { background: #00ff00; }
        .signal-ok .bar:nth-child(1), .signal-ok .bar:nth-child(2) { background: #ffff00; }
        .signal-bad .bar:nth-child(1) { background: #ff0000; }
        
        #ai-feedback-overlay { display: none; }
        #zoom-target-indicator { position: absolute; width: 60px; height: 60px; border: 2px solid #00ff00; border-radius: 50%; transform: translate(-50%, -50%) scale(0.5); opacity: 0; pointer-events: none; z-index: 80; box-shadow: 0 0 15px #00ff00; transition: transform 0.3s, opacity 0.3s; }
        #zoom-target-indicator.active { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    </style>
</head>
<body>

    <div id="orientation-lock">
        <img src="obr-logo.png" class="w-32 h-32 object-contain mb-6 animate-pulse drop-shadow-[0_0_20px_rgba(255,0,0,0.6)]">
        <i class="fas fa-mobile-alt text-4xl mb-4 rotate-90 text-red-500"></i>
        <h2 class="text-xl font-bold font-orbitron tracking-widest text-red-500 mb-2">SISTEMA PAUSADO</h2>
        <p class="text-sm font-mono text-gray-400">COLOCA EN HORIZONTAL</p>
    </div>

    <div id="main-view-area">
        <div id="zoom-container">
            <video id="shared-video-element" autoplay playsinline muted></video>
            <canvas id="sls-canvas"></canvas>
        </div>
    </div>
    
    <canvas id="heatmap-buffer"></canvas>
    <div id="touch-surface"></div>
    <div id="zoom-target-indicator"></div>

    <div id="ui-layer">
        <div id="tally-border"></div>
        <div id="sls-pip">● SLS ACTIVO</div>
        <div id="link-status" class="absolute bottom-4 left-4 text-[10px] font-mono text-gray-400 bg-black/60 px-2 py-1 rounded border border-gray-800">OFFLINE</div>
        <div class="absolute top-4 right-4 interactive text-gray-500 cursor-pointer p-2 bg-black/30 rounded-full" onclick="openSettings()"><i class="fas fa-cog text-xl"></i></div>
        
        <div id="perf-stats">
            <div id="res-fps">Init...</div>
            <div id="conn-stat" class="flex items-center justify-end mt-1">
                <span id="ping-val">--ms</span>
                <div class="signal-bars signal-bad" id="signal-ui">
                    <div class="bar" style="height: 30%"></div>
                    <div class="bar" style="height: 60%"></div>
                    <div class="bar" style="height: 100%"></div>
                </div>
            </div>
        </div>

        <div id="menu-left" class="menu-container left-side">
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('night', this)" id="btn-night"><i class="fas fa-moon"></i></div><div class="menu-label">NOCT</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('thermal', this)" id="btn-thermal"><i class="fas fa-fire"></i></div><div class="menu-label">NEG</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('urbex', this)" id="btn-urbex"><i class="fas fa-city"></i></div><div class="menu-label">URBEX</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('sls', this)" id="btn-sls"><i class="fas fa-ghost"></i></div><div class="menu-label">SLS</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="setFilter('heatmap', this)" id="btn-heatmap"><i class="fas fa-fire-alt"></i></div><div class="menu-label">HEAT</div></div>
        </div>
        <div id="menu-right" class="menu-container right-side">
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="togglePareidolia(this)" id="btn-ia"><i class="fas fa-eye"></i></div><div class="menu-label">VISION</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="openConnect()"><i class="fas fa-link"></i></div><div class="menu-label">LINK</div></div>
            <div onclick="event.stopPropagation()"><div class="menu-btn" onclick="resetZoom(this)"><i class="fas fa-compress"></i></div><div class="menu-label">RESET</div></div>
        </div>

        <div id="ai-vision-header">
            <img id="ai-mini-img" alt="Scan">
            <div id="ai-mini-text">ESPERANDO DATOS...</div>
        </div>
    </div>

    <div id="loading">
        <img src="obr-logo.png" class="w-24 h-24 object-contain mb-4 animate-pulse drop-shadow-[0_0_20px_rgba(220,38,38,0.5)]">
        <h1 class="text-3xl text-red-600 font-bold mb-1 tracking-widest font-orbitron">OBR CAM</h1>
        <p class="text-xs font-mono text-gray-500 mb-8">SYSTEM v213 (TAILSCALE READY)</p>
        <div id="progress-container"><div id="progress-bar"></div></div>
        <div id="progress-text">ESPERANDO INICIO...</div>
        <button class="load-btn" onclick="initApp()">INICIAR CÁMARA</button>
    </div>

    <div id="connect-modal" class="modal-bg">
        <div class="bg-neutral-900 border border-cyan-500 p-8 rounded-lg w-80 text-center shadow-[0_0_30px_rgba(0,255,255,0.1)]">
            <h3 class="text-cyan-400 mb-6 text-xl tracking-widest font-bold">ENLACE PRODOCK</h3>
            <input type="text" id="dock-id" placeholder="ID DEL DIRECTOR" class="w-full bg-black border border-gray-700 text-white p-4 text-center uppercase mb-6 text-xl outline-none focus:border-cyan-400 transition-colors rounded">
            <button onclick="connectToProdock()" class="w-full bg-cyan-900 text-white font-bold py-4 hover:bg-cyan-700 mb-4 rounded font-orbitron">CONECTAR</button>
            <button onclick="document.getElementById('connect-modal').classList.remove('active')" class="text-gray-500 text-xs hover:text-white">CANCELAR</button>
        </div>
    </div>

    <div id="settings-modal" class="modal-bg">
        <div class="bg-neutral-900 border border-red-900 p-6 rounded w-80 shadow-[0_0_30px_rgba(255,0,0,0.1)]">
            <h2 class="text-red-500 font-orbitron mb-4 font-bold">CONFIGURACIÓN</h2>
            <a href="https://aistudio.google.com/api-keys" target="_blank" class="flex items-center justify-center w-full border border-blue-900 text-blue-400 py-2 rounded hover:bg-blue-900/20 text-xs font-bold mb-4 transition-colors">
                <i class="fas fa-external-link-alt mr-2"></i> CONSEGUIR GEMINI API KEY
            </a>
            <input type="password" id="api-key-internal" placeholder="PEGAR API KEY AQUÍ" class="w-full bg-black border border-gray-700 p-3 text-white mb-2 text-sm rounded outline-none focus:border-red-500">
            <button id="btn-validate-api" onclick="validateAndSaveKey()" class="w-full border border-green-700 text-green-500 py-3 rounded hover:bg-green-900/20 font-bold mb-2">VALIDAR Y GUARDAR</button>
            <div id="api-status-msg" class="text-xs font-mono mt-2 text-center text-yellow-500"></div>

            <!-- NUEVA SECCION RED PRIVADA -->
            <div class="mt-4 pt-4 border-t border-gray-800">
                <h3 class="text-cyan-500 font-bold text-xs mb-3 flex items-center gap-2">
                    <i class="fas fa-network-wired"></i> RED PRIVADA (TAILSCALE / LAN)
                </h3>
                <div class="flex items-center gap-2 mb-3">
                    <input type="checkbox" id="use-local-server" class="accent-cyan-500 cursor-pointer" onclick="toggleLocalServerInputs()"/>
                    <label for="use-local-server" class="text-xs text-gray-400 cursor-pointer">USAR SERVIDOR PROPIO</label>
                </div>
                
                <div id="local-server-config" class="space-y-2 hidden opacity-50 transition-opacity duration-300">
                    <input type="text" id="local-host" placeholder="IP HOST (Ej: 100.x.x.x)" class="w-full bg-black border border-gray-700 p-2 text-white text-xs rounded font-mono uppercase">
                    <div class="flex gap-2">
                        <input type="number" id="local-port" placeholder="PUERTO (9000)" class="w-1/2 bg-black border border-gray-700 p-2 text-white text-xs rounded font-mono">
                        <input type="text" id="local-path" placeholder="RUTA (/myapp)" class="w-1/2 bg-black border border-gray-700 p-2 text-white text-xs rounded font-mono">
                    </div>
                    <div class="flex items-center gap-2 mt-2">
                         <input type="checkbox" id="local-secure" class="accent-cyan-500">
                         <label for="local-secure" class="text-[10px] text-gray-500">USAR SSL (HTTPS/WSS)</label>
                    </div>
                </div>
                <button onclick="saveNetworkSettings()" class="w-full mt-2 border border-cyan-800 text-cyan-500 py-2 rounded hover:bg-cyan-900/20 text-xs font-bold">GUARDAR CONFIG. RED</button>
            </div>

            <button onclick="document.getElementById('settings-modal').classList.remove('active')" class="w-full mt-3 text-gray-500 text-xs hover:text-white">CERRAR</button>
        </div>
    </div>

<script>
    const FILTER_CONFIG = {
        NOCT: { grayscale: '100%', sepia: '100%', hueRotate: '90deg', saturate: '100%', contrast: '1.1', brightness: '1.0' },
        NEG: { invert: '100%', grayscale: '100%', contrast: '200%', brightness: '1.0' },
        URBEX: { sepia: '50%', hueRotate: '-15deg', saturate: '90%', contrast: '1.1', brightness: '0.8' },
        HEATMAP: { contrast: '1.2', brightness: '0.7' }
    };

    let API_KEY = localStorage.getItem("obr_gemini_key") || "";
    let CURRENT_AI_MODEL = localStorage.getItem("obr_ai_model") || "gemini-2.5-flash-preview-09-2025";
    let GEMINI_API_KEY = API_KEY; 

    // CONFIGURACIÓN AI / VISUAL
    const AI_THRESHOLD = 0.02; 
    const SLS_LINE_COLOR = "#d946ef"; 
    const SLS_NODE_COLOR = "#a855f7"; 
    const SLS_LINE_WIDTH = 7.0; 

    let currentFilter = 'normal';
    let isSLSActive = false;
    let isHeatmapActive = false;
    let isPareidoliaActive = false;
    let isAIProcessing = false;
    
    // MODELOS
    let poseDetector = null;
    let faceMesh = null;
    let poses = [];
    let faces = [];
    let lastAITime = 0; // Para limitar FPS de IA
    
    let zoomLevel = 1; 
    let peer, conn;
    let deferredPrompt;
    let menuTimer;
    let videoStream;
    let fps = 0, frameCount = 0, lastTime = performance.now();
    let pareidoliaInterval = null;
    let audioCtx, micSource, destNode; 
    let lastPingTime = 0;
    let particleSprite;
    let logoImage = new Image(); logoImage.src = 'obr-logo.png';
    let timeString = "--:--:--";
    
    let drawW, drawH, drawX, drawY;

    const video = document.getElementById('shared-video-element');
    const slsCanvas = document.getElementById('sls-canvas');
    const heatCanvas = document.getElementById('heatmap-buffer');
    const ctx = slsCanvas.getContext('2d', { alpha: true });
    const heatCtx = heatCanvas.getContext('2d', { alpha: true });
    const zoomLayer = document.getElementById('zoom-container');
    const touchSurface = document.getElementById('touch-surface');

    const detCanvas = document.createElement('canvas');
    detCanvas.width = 192; detCanvas.height = 108; 
    const detCtx = detCanvas.getContext('2d', { willReadFrequently: true });

    function initHeatSprite() {
        const s = document.createElement('canvas'); s.width = 128; s.height = 128;
        const c = s.getContext('2d');
        const grad = c.createRadialGradient(64,64,0,64,64,64);
        grad.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
        grad.addColorStop(0.3, 'rgba(255, 165, 0, 0.6)');
        grad.addColorStop(0.6, 'rgba(255, 255, 0, 0.4)');
        grad.addColorStop(1, 'rgba(200, 200, 255, 0)');
        c.fillStyle = grad; c.fillRect(0,0,128,128);
        particleSprite = s;
    }

    function updateProgress(percent, text) {
        document.getElementById('progress-bar').style.width = percent + '%';
        document.getElementById('progress-text').innerText = text;
    }

    function initAudioMix(stream) {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            micSource = audioCtx.createMediaStreamSource(stream);
            destNode = audioCtx.createMediaStreamDestination();
            micSource.connect(destNode);
        } catch(e) { console.error("Audio mix failed", e); }
    }

    // --- ZOOM ---
    let pressTimer = null;
    const LONG_PRESS_MS = 600;
    touchSurface.addEventListener('pointerdown', (e) => {
        const w = window.innerWidth;
        const edgeThreshold = 100;
        if (e.clientX < edgeThreshold || e.clientX > w - edgeThreshold) { showMenus(); return; }
        pressTimer = setTimeout(() => { handleZoomPress(e.clientX, e.clientY); }, LONG_PRESS_MS);
    });
    touchSurface.addEventListener('pointerup', () => clearTimeout(pressTimer));
    touchSurface.addEventListener('pointerleave', () => clearTimeout(pressTimer));
    touchSurface.addEventListener('pointermove', () => clearTimeout(pressTimer));

    function handleZoomPress(x, y) {
        if(navigator.vibrate) navigator.vibrate(50);
        let nextZoom = (zoomLevel === 1) ? 3 : (zoomLevel === 3 ? 5 : 5);
        if(zoomLevel === 5) return;
        const ind = document.getElementById('zoom-target-indicator');
        ind.style.left = x + 'px'; ind.style.top = y + 'px';
        ind.classList.add('active'); setTimeout(() => ind.classList.remove('active'), 500);
        const originX = (x / window.innerWidth) * 100;
        const originY = (y / window.innerHeight) * 100;
        zoomLayer.style.transformOrigin = `${originX}% ${originY}%`;
        zoomLayer.style.transform = `scale(${nextZoom})`;
        zoomLevel = nextZoom;
    }

    function showMenus() {
        const left = document.getElementById('menu-left');
        const right = document.getElementById('menu-right');
        left.classList.add('visible'); right.classList.add('visible');
        clearTimeout(menuTimer);
        menuTimer = setTimeout(() => { left.classList.remove('visible'); right.classList.remove('visible'); }, 4000);
    }
    function resetZoom(btn) {
        if(btn) { btn.classList.add('active-state'); setTimeout(()=>btn.classList.remove('active-state'), 200); }
        zoomStage = 0; zoomLevel = 1;
        zoomLayer.style.transform = `scale(1)`;
        setTimeout(() => { zoomLayer.style.transformOrigin = `center center`; }, 400);
        hideMenus();
    }

    function updateClock() {
        const now = new Date();
        const d = String(now.getDate()).padStart(2, '0');
        const m = String(now.getMonth() + 1).padStart(2, '0');
        const y = String(now.getFullYear()).slice(-2);
        const h = String(now.getHours()).padStart(2, '0');
        const min = String(now.getMinutes()).padStart(2, '0');
        const s = String(now.getSeconds()).padStart(2, '0');
        timeString = `${d} - ${m} - ${y} | ${h}:${min}:${s}`;
    }

    window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); deferredPrompt = e; });
    window.onload = () => { 
        if(API_KEY) document.getElementById('api-key-internal').value = API_KEY;
        loadNetworkSettings(); // Cargar config de red
    };

    // --- CARGAR / GUARDAR SETTINGS DE RED ---
    function loadNetworkSettings() {
        const useLocal = localStorage.getItem('obr_use_local') === 'true';
        document.getElementById('use-local-server').checked = useLocal;
        if(useLocal) {
            document.getElementById('local-server-config').classList.remove('hidden');
            setTimeout(() => document.getElementById('local-server-config').classList.remove('opacity-50'), 50);
        }
        
        document.getElementById('local-host').value = localStorage.getItem('obr_local_host') || '';
        document.getElementById('local-port').value = localStorage.getItem('obr_local_port') || '9000';
        document.getElementById('local-path').value = localStorage.getItem('obr_local_path') || '/';
        document.getElementById('local-secure').checked = localStorage.getItem('obr_local_secure') === 'true';
    }

    function toggleLocalServerInputs() {
        const chk = document.getElementById('use-local-server');
        const div = document.getElementById('local-server-config');
        if(chk.checked) {
            div.classList.remove('hidden');
            setTimeout(() => div.classList.remove('opacity-50'), 50);
        } else {
            div.classList.add('opacity-50');
            setTimeout(() => div.classList.add('hidden'), 300);
        }
    }

    function saveNetworkSettings() {
        localStorage.setItem('obr_use_local', document.getElementById('use-local-server').checked);
        localStorage.setItem('obr_local_host', document.getElementById('local-host').value.trim());
        localStorage.setItem('obr_local_port', document.getElementById('local-port').value.trim());
        localStorage.setItem('obr_local_path', document.getElementById('local-path').value.trim());
        localStorage.setItem('obr_local_secure', document.getElementById('local-secure').checked);
        alert("Configuración de Red Guardada. Reinicia la app para aplicar cambios.");
    }

    // --- INIT APP (OPTIMIZADO PARA TEMPERATURA) ---
    async function initApp() {
        const btn = document.querySelector('.load-btn');
        const pBar = document.getElementById('progress-container');
        btn.disabled = true; btn.style.display = 'none'; pBar.style.display = 'block';
        
        try {
            updateProgress(10, "CONFIGURANDO SENSOR...");
            
            // RESOLUCIÓN REDUCIDA A 720p PARA EVITAR SOBRECALENTAMIENTO
            const constraints = {
                audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
                video: { 
                    facingMode: 'environment', 
                    width: { ideal: 1280 }, // 720p es mucho mas fresco
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }, // 30 FPS estable es mejor que 60 cayendo a 10
                    advanced: [{ focusMode: "continuous" }, { whiteBalanceMode: "continuous-auto" }, { exposureMode: "continuous" }]
                }
            };

            const camPromise = navigator.mediaDevices.getUserMedia(constraints)
                .catch(() => navigator.mediaDevices.getUserMedia({ audio: true, video: { facingMode: 'environment' } })); 
            
            const stream = await camPromise;
            const track = stream.getVideoTracks()[0];
            const capabilities = track.getCapabilities();
            if (capabilities && capabilities.focusMode) {
                try { await track.applyConstraints({ advanced: [{ focusMode: "continuous" }] }); } catch(e){}
            }
            
            videoStream = stream; video.srcObject = stream;
            initAudioMix(stream);
            initHeatSprite();
            
            video.play();
            updateProgress(30, "SENSOR ACTIVO");
            
            document.getElementById('loading').style.display = 'none';
            setInterval(updateClock, 1000); updateClock();
            resize(); renderLoop(); 
            setTimeout(loadModelsBackground, 200);
            
            window.addEventListener('resize', () => {
                clearTimeout(window.resizeTimer);
                window.resizeTimer = setTimeout(resize, 200);
            });
            
            setInterval(() => { if (video.paused && video.srcObject) video.play().catch(()=>{}); }, 2000);

        } catch(e) { alert("Error Inicio: " + e.message); location.reload(); }
    }

    async function warmUpAI() {
        try {
            detCtx.fillRect(0,0,192,108);
            if(poseDetector) { for(let i=0; i<3; i++) { await poseDetector.estimatePoses(detCanvas, {maxPoses: 1, flipHorizontal: false}); await new Promise(r => setTimeout(r, 20)); } }
            if(faceMesh) { for(let i=0; i<3; i++) { try { await faceMesh.send({image: detCanvas}); } catch(e){} await new Promise(r => setTimeout(r, 20)); } }
        } catch(e) {}
    }

    async function loadModelsBackground() {
        try {
            await tf.setBackend('webgl'); await tf.ready();
            try {
                poseDetector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, { modelType: poseDetection.movenet.modelType.MULTIPOSE_LIGHTNING, modelUrl: 'indexeddb://obr-movenet-lightning' });
            } catch(e) {
                poseDetector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, { modelType: poseDetection.movenet.modelType.MULTIPOSE_LIGHTNING });
            }
            faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            faceMesh.setOptions({ maxNumFaces: 5, refineLandmarks: true, minDetectionConfidence: AI_THRESHOLD, minTrackingConfidence: AI_THRESHOLD });
            faceMesh.onResults((results) => { if(results.multiFaceLandmarks) faces = results.multiFaceLandmarks; else faces = []; });
            await warmUpAI();
            aiLoop(); // BUCLE AI SEPARADO
        } catch(e) { console.error("AI Load Fail:", e); }
    }

    function resize() { 
        slsCanvas.width = window.innerWidth; 
        slsCanvas.height = window.innerHeight; 
        heatCanvas.width = window.innerWidth; 
        heatCanvas.height = window.innerHeight; 
    }

    // --- NUEVO SISTEMA DE DIBUJO DE HUD EN CANVAS (TRANSMITE EN VIDEO) ---
    function drawHUD(c) {
        c.save();
        // Escala del HUD
        const scale = 0.85;
        const x = 20; const y = 20;
        
        // Simular Glitch leve
        const jitterX = Math.random() > 0.95 ? (Math.random() - 0.5) * 5 : 0;
        
        c.translate(x + jitterX, y);
        c.scale(scale, scale);
        
        // Logo
        if (logoImage.complete) {
            c.shadowColor = "rgba(255,0,0,0.6)"; c.shadowBlur = 10;
            c.drawImage(logoImage, 0, 0, 40, 40);
        }
        
        // Texto Titulo
        c.fillStyle = "#ffffff";
        c.font = "800 16px 'Orbitron', sans-serif";
        c.shadowColor = "rgba(0,0,0,0.8)"; c.shadowBlur = 0; c.shadowOffsetX = 2; c.shadowOffsetY = 2;
        c.fillText("EXPLORACIONES OBR", 52, 20);
        
        // Texto Hora
        c.fillStyle = "#ff3333";
        c.font = "14px 'Share Tech Mono', monospace";
        c.shadowOffsetX = 1; c.shadowOffsetY = 1;
        c.fillText(timeString, 52, 38);
        
        c.restore();
    }

    function renderLoop() {
        requestAnimationFrame(renderLoop);
        if(window.innerHeight > window.innerWidth) return; // Pausa en vertical

        const now = performance.now(); frameCount++;
        if (now - lastTime >= 1000) {
            const t = video.srcObject ? video.srcObject.getVideoTracks()[0].getSettings() : null;
            document.getElementById('res-fps').innerText = `${t.width}x${t.height} | ${frameCount}FPS`;
            if(conn && conn.open) {
                const nowTs = Date.now();
                if(nowTs - lastPingTime > 5000) { document.getElementById('signal-ui').className = "signal-bars signal-bad"; document.getElementById('ping-val').innerText = "TIMEOUT"; }
            }
            frameCount = 0; lastTime = now;
        }

        ctx.filter = 'none'; 
        // Aplicar filtros visuales al contexto (esto afecta lo que ve el usuario local Y lo que se envía por stream)
        if(currentFilter === 'night') {
            const c = FILTER_CONFIG.NOCT;
            ctx.filter = `grayscale(${c.grayscale}) sepia(${c.sepia}) hue-rotate(${c.hueRotate}) saturate(${c.saturate}) contrast(${c.contrast}) brightness(${c.brightness})`;
        } else if(currentFilter === 'thermal') {
            const c = FILTER_CONFIG.NEG;
            ctx.filter = `invert(${c.invert}) grayscale(${c.grayscale}) contrast(${c.contrast}) brightness(${c.brightness})`;
        } else if(currentFilter === 'urbex') {
            const c = FILTER_CONFIG.URBEX;
            ctx.filter = `sepia(${c.sepia}) hue-rotate(${c.hueRotate}) saturate(${c.saturate}) contrast(${c.contrast}) brightness(${c.brightness})`;
        } else if(currentFilter === 'heatmap') {
            const c = FILTER_CONFIG.HEATMAP;
            ctx.filter = `contrast(${c.contrast}) brightness(${c.brightness})`;
        }

        // SMART CROP
        if (video.videoWidth > 0 && slsCanvas.width > 0) {
            const vRatio = video.videoWidth / video.videoHeight;
            const cRatio = slsCanvas.width / slsCanvas.height;
            if (cRatio > vRatio) { drawW = slsCanvas.width; drawH = slsCanvas.width / vRatio; drawX = 0; drawY = (slsCanvas.height - drawH) / 2; } 
            else { drawW = slsCanvas.height * vRatio; drawH = slsCanvas.height; drawX = (slsCanvas.width - drawW) / 2; drawY = 0; }
            ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, drawX, drawY, drawW, drawH);
        } else {
            drawW = slsCanvas.width; drawH = slsCanvas.height; drawX = 0; drawY = 0;
        }
        
        // Heatmap
        if(isHeatmapActive) {
            ctx.filter = 'none'; 
            heatCtx.globalCompositeOperation = 'destination-out';
            heatCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            heatCtx.fillRect(0, 0, heatCanvas.width, heatCanvas.height);
            heatCtx.globalCompositeOperation = 'source-over';
            if(poses.length > 0) {
                const mapX = (val) => (val / detCanvas.width) * drawW + drawX;
                const mapY = (val) => (val / detCanvas.height) * drawH + drawY;
                poses.forEach(pose => {
                    const k = pose.keypoints;
                    k.forEach(p => {
                         if(p.score > AI_THRESHOLD) {
                             const px = mapX(p.x); const py = mapY(p.y);
                             heatCtx.drawImage(particleSprite, px - 60, py - 60, 120, 120);
                         }
                    });
                });
            }
            ctx.globalAlpha = 0.8; ctx.globalCompositeOperation = 'screen'; 
            ctx.drawImage(heatCanvas, 0, 0); 
            ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1.0;
        }

        // SLS
        if(isSLSActive && !isHeatmapActive) {
            if(poses.length > 0) drawSLS(poses);
            if(faces.length > 0) drawFaceMesh(faces);
        }

        // DIBUJAR HUD SOBRE EL VIDEO (SIN FILTROS DE COLOR)
        ctx.filter = 'none';
        drawHUD(ctx);
    }

    function drawSLS(poses) {
        ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        const mapX = (val) => (val / detCanvas.width) * drawW + drawX;
        const mapY = (val) => (val / detCanvas.height) * drawH + drawY;
        const pulse = (Math.sin(Date.now() / 150) + 1) / 2;
        poses.forEach(pose => {
            const k = pose.keypoints;
            const edges = [['left_shoulder','right_shoulder'],['left_shoulder','left_elbow'],['left_elbow','left_wrist'],['right_shoulder','right_elbow'],['right_elbow','right_wrist'],['left_shoulder','left_hip'],['right_shoulder','right_hip'],['left_hip','right_hip'],['left_hip','left_knee'],['left_knee','left_ankle'],['right_hip','right_knee'],['right_knee','right_ankle']];
            ctx.shadowBlur = 0; ctx.strokeStyle = SLS_LINE_COLOR; ctx.lineWidth = SLS_LINE_WIDTH;
            ctx.beginPath(); edges.forEach(([a,b]) => { const p1=k.find(p=>p.name==a), p2=k.find(p=>p.name==b); if(p1.score>AI_THRESHOLD && p2.score>AI_THRESHOLD) { ctx.moveTo(mapX(p1.x),mapY(p1.y)); ctx.lineTo(mapX(p2.x),mapY(p2.y)); } }); ctx.stroke();
            const nose = k.find(p => p.name === 'nose'); const lShoulder = k.find(p => p.name === 'left_shoulder'); const rShoulder = k.find(p => p.name === 'right_shoulder');
            if (lShoulder && rShoulder && lShoulder.score > 0.1 && rShoulder.score > 0.1) {
                const neckX = (mapX(lShoulder.x) + mapX(rShoulder.x)) / 2; const neckY = (mapY(lShoulder.y) + mapY(rShoulder.y)) / 2;
                ctx.beginPath(); ctx.moveTo(mapX(lShoulder.x), mapY(lShoulder.y)); ctx.lineTo(neckX, neckY); ctx.lineTo(mapX(rShoulder.x), mapY(rShoulder.y)); ctx.stroke();
                if (nose && nose.score > 0.1) { ctx.beginPath(); ctx.moveTo(neckX, neckY); ctx.lineTo(mapX(nose.x), mapY(nose.y)); ctx.stroke(); }
            }
            ctx.fillStyle = SLS_NODE_COLOR; ctx.shadowBlur = 15; ctx.shadowColor = 'red';
            k.forEach(p => { if(p.score > AI_THRESHOLD && !p.name.includes('ear')) { const r = 5 + (pulse * 3); ctx.beginPath(); ctx.arc(mapX(p.x), mapY(p.y), r, 0, 2*Math.PI); ctx.fill(); } });
            ctx.shadowBlur = 0;
        });
    }

    function drawFaceMesh(faces) {
        if(faces.length === 0) return;
        faces.forEach(face => {
            const points = face.multiFaceLandmarks ? face.multiFaceLandmarks[0] : face; 
            ctx.fillStyle = '#39ff14'; 
            for(let i=0; i<points.length; i++) { const p = points[i]; ctx.fillRect(p.x * drawW + drawX, p.y * drawH + drawY, 2, 2); }
            const xs = points.map(p => p.x * drawW + drawX); const ys = points.map(p => p.y * drawH + drawY);
            const minX = Math.min(...xs)-20; const maxX = Math.max(...xs)+20; const minY = Math.min(...ys)-30; const maxY = Math.max(...ys)+30;
            ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = 'red'; ctx.strokeRect(minX, minY, maxX-minX, maxY-minY);
        });
    }

    // BUCLE DE IA LIMITADO (THROTTLE) PARA REDUCIR CALENTAMIENTO
    async function aiLoop() {
        while(true) {
            const now = Date.now();
            if (now - lastAITime > 100) { // Max 10 calculos por segundo
                if(poseDetector && (isSLSActive || isHeatmapActive || isPareidoliaActive)) { 
                    try { 
                        detCtx.drawImage(video, 0, 0, detCanvas.width, detCanvas.height); 
                        poses = await poseDetector.estimatePoses(detCanvas, {maxPoses: 5, flipHorizontal: false, scoreThreshold: AI_THRESHOLD}); 
                    } catch(e){} 
                } else { poses = []; }

                if(faceMesh && isSLSActive && !isHeatmapActive) { 
                    try { await faceMesh.send({image: video}); } catch(e) {} 
                } else { faces = []; }
                lastAITime = now;
            }
            await new Promise(r => setTimeout(r, 20)); // Pequeña pausa
        }
    }

    function openConnect() { document.getElementById('connect-modal').classList.add('active'); }
    async function connectToProdock() {
        const id = document.getElementById('dock-id').value.trim();
        if(!id) return;
        document.getElementById('connect-modal').classList.remove('active');
        
        // --- LOGICA DE CONEXION (LOCAL VS NUBE) ---
        const useLocal = localStorage.getItem('obr_use_local') === 'true';
        const localHost = localStorage.getItem('obr_local_host');
        const localPort = localStorage.getItem('obr_local_port');
        const localPath = localStorage.getItem('obr_local_path');
        const localSecure = localStorage.getItem('obr_local_secure') === 'true';

        let peerOptions = {};

        if (useLocal && localHost && localPort) {
            console.log("Conectando vía Servidor Local/Tailscale...");
            // Indicador visual de modo local
            document.getElementById('link-status').innerText = "ENLACE: SERVIDOR PRIVADO";
            document.getElementById('link-status').className = "absolute bottom-4 left-4 text-[10px] font-mono text-purple-400 bg-purple-900/40 px-2 py-1 rounded border border-purple-500 font-bold shadow-[0_0_10px_purple]";
            
            peerOptions = {
                host: localHost,
                port: parseInt(localPort),
                path: localPath || '/',
                secure: localSecure,
                debug: 1,
                // Al usar IP directa (VPN/LAN), a veces es mejor desactivar ICE servers públicos para forzar ruta directa,
                // o dejarlos vacíos si la red es plana (como Tailscale).
                config: { iceServers: [] } 
            };
        } else {
            console.log("Conectando vía Nube Pública...");
            peerOptions = { 
                debug: 1, 
                config: { 
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }, 
                        { urls: 'stun:stun1.l.google.com:19302' }, 
                        { urls: 'stun:global.stun.twilio.com:3478' },
                        // Open Relay (Free TURN)
                        { urls: "turn:openrelay.metered.ca:80", username: "openrelayproject", credential: "openrelayproject" },
                        { urls: "turn:openrelay.metered.ca:443", username: "openrelayproject", credential: "openrelayproject" },
                        { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelayproject", credential: "openrelayproject" }
                    ] 
                } 
            };
        }

        peer = new Peer(null, peerOptions);
        
        setInterval(() => { if(conn && conn.open) { conn.send({ type: 'ping', time: Date.now() }); } }, 2000);
        peer.on('open', myId => {
            conn = peer.connect(id);
            conn.on('open', () => {
                if(!useLocal) {
                    document.getElementById('link-status').innerText = "ENLACE: VPN PRODOCK (SEGURO)";
                    document.getElementById('link-status').className = "absolute bottom-4 left-4 text-[10px] font-mono text-cyan-400 bg-cyan-900/40 px-2 py-1 rounded border border-cyan-500 font-bold shadow-[0_0_10px_cyan]";
                }
                conn.send({ type: 'register', name: 'CAM-' + myId.substr(0,3) });
            });
            conn.on('data', d => {
                if(d.type === 'tally') document.getElementById('tally-border').className = d.state !== 'idle' ? d.state : '';
                if(d.type === 'pong') { lastPingTime = Date.now(); const latency = Date.now() - d.time; document.getElementById('ping-val').innerText = latency + "ms"; const sig = document.getElementById('signal-ui'); if(latency < 100) sig.className = "signal-bars signal-good"; else if(latency < 300) sig.className = "signal-bars signal-ok"; else sig.className = "signal-bars signal-bad"; }
                if(d.type === 'cmd') {
                    if(d.action === 'filter') {
                        const btnMap = { 'night': 'btn-night', 'thermal': 'btn-thermal', 'urbex': 'btn-urbex', 'sls': 'btn-sls', 'heatmap': 'btn-heatmap', 'normal': null };
                        if(d.value === 'normal') setFilter('normal');
                        else if(btnMap[d.value]) {
                            setFilter(d.value, document.getElementById(btnMap[d.value]));
                        }
                    }
                    if(d.action === 'toggle' && d.value === 'pareidolia') togglePareidolia(document.getElementById('btn-ia'));
                    if(d.action === 'reset') { setFilter('normal'); resetZoom(); }
                }
            });
            const streamToSend = slsCanvas.captureStream(30); 
            if(destNode) streamToSend.addTrack(destNode.stream.getAudioTracks()[0]);
            else { const audioTrack = video.srcObject.getAudioTracks()[0]; if(audioTrack) streamToSend.addTrack(audioTrack); }
            peer.call(id, streamToSend);
        });
    }

    function setFilter(f, btn) {
        if(currentFilter === f && f !== 'normal') { setFilter('normal'); return; }
        currentFilter = f;
        
        isSLSActive = (f === 'sls');
        isHeatmapActive = (f === 'heatmap');
        
        document.querySelectorAll('.menu-btn').forEach(b => b.classList.remove('active-state')); 
        if(btn && f !== 'normal') btn.classList.add('active-state');
        
        document.body.classList.remove('filter-night-vision', 'filter-thermal', 'filter-urbex', 'filter-pareidolia', 'filter-heatmap');
        
        // IMPORTANTE: Al aplicar la clase, el CSS 'body.filter-night-vision #main-view-area::after' se activa
        if(f === 'night') { document.body.classList.add('filter-night-vision'); toggleTorch(true); } else { toggleTorch(false); }
        if(f === 'thermal') document.body.classList.add('filter-thermal');
        if(f === 'urbex') document.body.classList.add('filter-urbex');
        if(f === 'sls') document.body.classList.add('filter-pareidolia');

        document.getElementById('sls-pip').style.display = isSLSActive ? 'block' : 'none';
        if(isPareidoliaActive) togglePareidolia();
    }
    
    async function toggleTorch(enable) {
        if (!videoStream) return;
        const track = videoStream.getVideoTracks()[0];
        try { await track.applyConstraints({ advanced: [{ torch: enable }] }); } catch (e) {}
    }

    function speakText(t) { 
        if ('speechSynthesis' in window) { 
            window.speechSynthesis.cancel(); 
            const u = new SpeechSynthesisUtterance(t); 
            u.lang = 'es-ES'; u.pitch = 0.6; u.rate = 0.9; 
            u.onend = () => { setTimeout(() => { isAIProcessing = false; }, 2000); };
            u.onerror = () => { isAIProcessing = false; };
            window.speechSynthesis.speak(u);
            
            if(conn && conn.open) {
                conn.send({ type: 'ai-speech', text: t });
            }
        } else { setTimeout(() => { isAIProcessing = false; }, 2000); }
    }

    async function triggerPareidolia() { 
        if(!GEMINI_API_KEY) return; 
        if(isAIProcessing || window.speechSynthesis.speaking) return; 
        isAIProcessing = true; 
        const canvas = document.createElement('canvas'); canvas.width = 640; canvas.height = 360; 
        canvas.getContext('2d').drawImage(video, 0, 0, 640, 360); 
        const base64 = canvas.toDataURL('image/jpeg', 0.6).split(',')[1]; 
        const prompt = "Actúa como un médium digital. Describe en primera persona lo que ves. Usa frases como 'Veo...', 'Hay algo en...', 'Está...'. Busca caras en las sombras. Sé siniestro. Max 12 palabras."; 
        try { 
            let attempts = 0; let success = false; let data = null;
            while(attempts < 3 && !success) {
                try {
                     const modelToUse = CURRENT_AI_MODEL || "gemini-2.5-flash-preview-09-2025";
                     const resp = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelToUse}:generateContent?key=${GEMINI_API_KEY}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/jpeg", data: base64 } }] }] }) }); 
                     data = await resp.json();
                     if (data.candidates && data.candidates[0].content) { success = true; } else { attempts++; await new Promise(r => setTimeout(r, 1000)); }
                } catch(err) { attempts++; }
            }
            let text = success ? (data.candidates?.[0]?.content?.parts?.[0]?.text || "ANOMALIA DETECTADA").replace(/[*_]/g, '').trim() : "SIN DATOS CLAROS";
            if(text.length < 3) text = "SIN DATOS CLAROS"; 
            const aiHeader = document.getElementById('ai-vision-header'); const aiImg = document.getElementById('ai-mini-img'); const aiText = document.getElementById('ai-mini-text');
            aiImg.src = canvas.toDataURL(); aiText.innerText = text.toUpperCase(); aiHeader.classList.add('active');
            speakText(text); 
        } catch(e) { console.log(e); isAIProcessing = false; } 
    }

    function togglePareidolia(btnElement) { 
        if(!GEMINI_API_KEY) { alert("NO API KEY"); return; } 
        const btn = btnElement || document.getElementById('btn-ia');
        isPareidoliaActive = !isPareidoliaActive; 
        if(isPareidoliaActive) { 
            if(btn) btn.classList.add('active-state');
            document.body.classList.add('filter-pareidolia'); 
            speakText("VISIÓN ACTIVADA"); triggerPareidolia(); pareidoliaInterval = setInterval(triggerPareidolia, 8000); 
        } else { 
            if(btn) btn.classList.remove('active-state');
            document.body.classList.remove('filter-pareidolia'); 
            speakText("VISIÓN DESACTIVADA"); clearInterval(pareidoliaInterval); 
            isAIProcessing = false; 
            const aiHeader = document.getElementById('ai-vision-header');
            if(aiHeader) aiHeader.classList.remove('active'); 
        } 
        showMenus(); 
    }

    async function validateAndSaveKey() { 
        const input = document.getElementById('api-key-internal'); 
        const btn = document.getElementById('btn-validate-api'); 
        const status = document.getElementById('api-status-msg'); 
        const k = input.value.trim(); 
        if(!k) { status.innerText = "❌ CAMPO VACIO"; return; } 
        input.disabled = true; btn.disabled = true; 
        const modelsToTry = ["gemini-2.5-flash-preview-09-2025", "gemini-1.5-flash", "gemini-1.5-pro"];
        let workingModel = null;
        for(const step of ["CONECTANDO...", "ENVIANDO PING...", "VERIFICANDO..."]) { status.innerText = step; await new Promise(r => setTimeout(r, 400)); } 
        for (const model of modelsToTry) {
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${k}`, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ contents: [{ parts: [{ text: "ping" }] }] }) }); 
                if(response.ok) { workingModel = model; break; }
            } catch(e) {}
        }
        if(workingModel) { 
            status.innerText = "✅ ACTIVA (" + workingModel.replace("gemini-","").split("-")[0] + ")"; status.style.color = "#00ff41"; 
            GEMINI_API_KEY = k; CURRENT_AI_MODEL = workingModel;
            localStorage.setItem('obr_gemini_key', k); localStorage.setItem('obr_ai_model', workingModel); 
        } else { status.innerText = "❌ ERROR: LLAVE INVALIDA"; status.style.color = "red"; } 
        input.disabled = false; btn.disabled = false; btn.innerText = "VALIDAR"; 
    }

    function openSettings() { document.getElementById('settings-modal').classList.add('active'); }
</script>
</body>
</html>
