<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ESTUDIO EXPLORACIONES OBR | STUDIO v6.1.2 PRO (NATIVE OBS FIX)</title>
    
    <link rel="icon" type="image/png" href="./obr-logo.png">
    <link rel="apple-touch-icon" href="./obr-logo.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    
    <link rel="manifest" href='data:application/manifest+json,{"name":"PRODOCK STUDIO","short_name":"PRODOCK","start_url":".","display":"standalone","background_color":"#000000","theme_color":"#000000","icons":[{"src":"./obr-logo.png","sizes":"192x192","type":"image/png"},{"src":"./obr-logo.png","sizes":"512x512","type":"image/png"}]}'>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- OBS LIBRARY REMOVED: STRICTLY NATIVE WEBSOCKET -->

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        body { background-color: #000; color: white; overflow: hidden; touch-action: manipulation; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
        
        @keyframes fade-in { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fade-in 0.3s ease-out forwards; }
        
        .director-scroll { -webkit-overflow-scrolling: touch; overflow-y: auto; scroll-behavior: smooth; }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }
        
        .preview-selected { box-shadow: 0 0 0 2px #22c55e; background-color: rgba(22, 163, 74, 0.2); }

        @keyframes pop-in { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .animate-pop-in { animation: pop-in 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        
        @keyframes pulse-red { 0%, 100% { background-color: rgba(220, 38, 38, 0.1); } 50% { background-color: rgba(220, 38, 38, 0.3); } }
        .emergency-mode { animation: pulse-red 2s infinite; border: 2px solid #dc2626; }

        .soft-mask {
            mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%), linear-gradient(to right, transparent 0%, black 10%, black 90%, transparent 100%);
            mask-composite: intersect;
            -webkit-mask-image: -webkit-linear-gradient(top, transparent 0%, black 15%, black 85%, transparent 100%), -webkit-linear-gradient(left, transparent 0%, black 10%, black 90%, transparent 100%);
            -webkit-mask-composite: source-in;
        }
        
        /* FIX CALIDAD VIDEO */
        video {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: high-quality;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="react">
        import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { createPortal } from 'react-dom';
        import { 
            Monitor, Wifi, Mic, MicOff, Activity, Maximize, X, 
            Settings, Eye, Moon, Flame, Ghost, Play, Volume2, VolumeX, Pause,
            Aperture, Radio, Film, Layers, Zap, Smartphone, Clapperboard, Power, ExternalLink, Edit2, Trash2, Disc, Video, AlertTriangle, CheckCircle, Signal, Globe, Box, Link2, Info, Share2, Music, UserPlus, RefreshCw, ScanLine, RotateCcw, Database, Copy, AlertOctagon, Loader2, Link, ShieldAlert
        } from 'lucide-react';
        
        const STUDIO_ASSETS = {
            intro: './INTRO_1.mp4',
            outro: './FIN_DIRECTO.mp4',
            banner: './BANNER_1.mp4',
            standby: './VIDEO-ESPERA.mp4',
            transicion: './transicion.mp4',
            backup1: './BACKUP_1.mp4', 
            backup2: './BACKUP_2.mp4'  
        };

        const PEER_CONFIG = {
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ],
                sdpSemantics: 'unified-plan',
                pingInterval: 5000 
            }
        };

        const triggerHaptic = (pattern = 15) => {
            if (navigator.vibrate) {
                try { navigator.vibrate(pattern); } catch(e) {}
            }
        };

        const useWakeLock = (active = true) => {
            const wakeLock = useRef(null);
            useEffect(() => {
                if (!active || !('wakeLock' in navigator)) return;
                const requestWakeLock = async () => {
                    try { wakeLock.current = await navigator.wakeLock.request('screen'); } catch (err) {}
                };
                requestWakeLock();
                const handleVisibilityChange = () => {
                    if (document.visibilityState === 'visible' && wakeLock.current === null) requestWakeLock();
                };
                document.addEventListener('visibilitychange', handleVisibilityChange);
                return () => {
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                    if (wakeLock.current) wakeLock.current.release();
                    wakeLock.current = null;
                };
            }, [active]);
        };

        const ShareModal = ({ onClose, dockId }) => (
            <div className="fixed inset-0 z-[200] bg-black/90 flex items-center justify-center p-4 animate-fade-in">
                <div className="bg-[#111] p-6 rounded-2xl border border-red-900/30 max-w-sm w-full text-center relative shadow-2xl">
                    <button onClick={onClose} className="absolute top-4 right-4 text-neutral-500 hover:text-white"><X size={20}/></button>
                    <h3 className="text-white font-bold text-lg mb-6 uppercase tracking-widest text-red-500">Compartir Estudio</h3>
                    <div className="bg-white/5 p-4 rounded-lg mb-6 border border-white/10">
                         <div className="text-3xl font-mono font-bold text-white mb-2 tracking-widest">{dockId}</div>
                         <div className="text-[10px] text-gray-500 uppercase tracking-widest">ID Único de Sesión</div>
                    </div>
                    <button onClick={() => { navigator.clipboard.writeText(dockId); triggerHaptic(20); onClose(); }} className="w-full bg-red-800 hover:bg-red-700 text-white font-bold py-4 rounded-lg uppercase tracking-widest flex items-center justify-center gap-2 transition-colors">
                        <Copy size={16}/> Copiar ID
                    </button>
                </div>
            </div>
        );

        const PeekModal = ({ stream, name, onClose }) => (
            <div className="fixed inset-0 z-[200] bg-black/60 backdrop-blur-sm flex items-center justify-center animate-fade-in" onClick={onClose}>
                <div className="relative w-[85%] max-w-lg aspect-video bg-black border-2 border-yellow-600 rounded-lg shadow-2xl overflow-hidden animate-pop-in" onClick={(e) => e.stopPropagation()}>
                    <button onClick={onClose} className="absolute top-2 right-2 z-20 bg-black/50 p-1 rounded-full text-white hover:bg-red-600 transition-colors"><X size={16}/></button>
                    <div className="absolute top-0 left-0 bg-yellow-600/90 text-black font-bold text-xs px-3 py-1 z-10 uppercase tracking-widest shadow-md">PEEK: {name}</div>
                    <video ref={(v) => { if(v) { v.srcObject = stream; v.play().catch(e=>console.log(e)); } }} className="w-full h-full object-cover" autoPlay playsInline muted />
                </div>
            </div>
        );
        
        const ZoomModal = ({ stream, name, onClose }) => (
            <div className="fixed inset-0 z-[200] bg-black/80 backdrop-blur-md flex items-center justify-center p-4 animate-fade-in" onClick={onClose}>
                <div className="relative w-full max-w-5xl aspect-video bg-black border-2 border-green-500 rounded-xl shadow-[0_0_50px_rgba(22,163,74,0.3)] overflow-hidden animate-pop-in" onClick={(e) => e.stopPropagation()}>
                    <button onClick={onClose} className="absolute top-4 right-4 z-30 bg-black/50 hover:bg-red-600 text-white p-2 rounded-full backdrop-blur transition-colors"><X size={24}/></button>
                    <div className="absolute top-4 left-4 z-30 flex items-center gap-2">
                        <div className="bg-green-600 text-white text-xs font-bold px-3 py-1 rounded shadow-lg uppercase tracking-widest animate-pulse">LIVE ZOOM</div>
                        <div className="bg-black/60 text-white text-xs font-bold px-3 py-1 rounded border border-white/10 uppercase tracking-widest">{name}</div>
                    </div>
                    {stream ? (
                         <video ref={(v) => { if(v) { v.srcObject = stream; v.play().catch(()=>console.log('Autoplay blocked')); } }} className="w-full h-full object-contain" autoPlay playsInline muted />
                    ) : (
                         <div className="w-full h-full flex items-center justify-center text-gray-500 font-mono tracking-widest">SEÑAL NO DISPONIBLE</div>
                    )}
                </div>
            </div>
        );

        const usePeerJS = () => {
          const [loaded, setLoaded] = useState(false);
          useEffect(() => {
            if (window.Peer) { setLoaded(true); return; }
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
            script.async = true;
            script.onload = () => setLoaded(true);
            document.body.appendChild(script);
          }, []);
          return loaded;
        };

        const VideoPeer = ({ stream, className, muted = true, id }) => {
            const videoRef = useRef(null);
            useEffect(() => { 
                const vid = videoRef.current;
                if (vid) { 
                    vid.muted = muted;
                    if (stream && vid.srcObject !== stream) {
                        vid.srcObject = stream; 
                        vid.play().catch(e => {});
                    }
                } 
            }, [stream, muted]);
            return <video id={id} ref={videoRef} autoPlay playsInline muted={muted} className={className} />;
        };

        const ToastContainer = ({ notifications }) => (
            <div className="fixed top-16 left-4 z-[100] flex flex-col gap-2 pointer-events-none w-64">
                {notifications.map(n => (
                    <div key={n.id} className={`flex items-center gap-3 px-3 py-3 rounded-lg shadow-2xl border-l-4 pointer-events-auto animate-fade-in backdrop-blur-xl transition-all ${n.type === 'error' ? 'bg-red-950/80 border-red-500 text-white' : n.type === 'warning' ? 'bg-yellow-950/80 border-yellow-500 text-white' : 'bg-green-950/80 border-green-500 text-white'}`}>
                        <div className="shrink-0">{n.type === 'error' ? <AlertTriangle size={18} /> : n.type === 'warning' ? <Activity size={18} /> : <CheckCircle size={18} />}</div>
                        <div className="flex flex-col overflow-hidden">
                            <span className="text-[10px] font-bold uppercase tracking-widest leading-none mb-1 opacity-50">{n.type === 'error' ? 'Alerta' : 'Info'}</span>
                            <span className="text-xs font-bold leading-tight truncate">{n.msg}</span>
                        </div>
                    </div>
                ))}
            </div>
        );

        const MediaOverlay = ({ activeMedia, blobAssets, onFinish, onTimeUpdate }) => {
            if (!activeMedia || !blobAssets[activeMedia]) return null;
            const src = blobAssets[activeMedia];
            
            const isBanner = activeMedia === 'banner';
            // MEJORA: Por defecto object-cover para que INTRO/OUTRO llenen la pantalla
            // Excepto si es banner que requiere masking especial
            let containerStyle = "absolute inset-0 z-50 bg-black flex items-center justify-center";
            let videoStyle = "w-full h-full object-cover"; // FIX: AJUSTE AL RECUADRO (COVER)
            
            if (isBanner) { 
                containerStyle = "absolute bottom-0 left-0 w-full h-[150px] z-40 flex items-center justify-center pointer-events-none pb-0 bg-transparent soft-mask"; 
                videoStyle = "w-full h-full object-cover opacity-95"; 
            } else if (activeMedia === 'transicion') { 
                containerStyle = "absolute inset-0 z-[60] flex items-center justify-center pointer-events-none bg-transparent"; 
                // Transición también cover
            }
            
            const shouldLoop = activeMedia === 'standby'; 
            return (
                <div className={containerStyle}>
                    <video key={activeMedia} src={src} autoPlay loop={shouldLoop} playsInline className={videoStyle} onTimeUpdate={(e) => onTimeUpdate && onTimeUpdate(e.target.duration, e.target.currentTime)} onEnded={() => { if (!shouldLoop && onFinish) { onFinish(); } }} onError={() => { if(onFinish) onFinish(); }} />
                </div>
            );
        };

        const StatusIndicators = ({ isLive, isRec, isObs, isFailover }) => (
            <div className="flex items-center gap-4 ml-4 border-l border-neutral-800 pl-4">
                {[
                    { label: 'OBS', active: isObs },
                    { label: 'LIVE', active: isLive },
                    { label: 'REC', active: isRec }
                ].map((item) => (
                    <div key={item.label} className="flex items-center gap-2 select-none transition-all opacity-90">
                        <div className={`w-2 h-2 rounded-full shadow-[0_0_8px_currentColor] transition-colors duration-300 ${item.active ? 'bg-green-500 text-green-500 shadow-[0_0_10px_#22c55e]' : 'bg-red-900 text-red-900'}`}></div>
                        <span className={`text-[9px] font-bold uppercase tracking-widest transition-colors duration-300 ${item.active ? 'text-white' : 'text-neutral-600'}`}>{item.label}</span>
                    </div>
                ))}
                {isFailover && (
                     <div className="flex items-center gap-2 select-none animate-pulse">
                        <div className="w-2 h-2 rounded-full bg-yellow-500 shadow-[0_0_10px_#eab308]"></div>
                        <span className="text-[9px] font-bold uppercase tracking-widest text-yellow-500">BACKUP ON</span>
                    </div>
                )}
            </div>
        );

        const DirectorPanel = ({ activeCam, onCommand, isOffline, currentFilter }) => {
            const handleFilterToggle = (filterName) => { 
                triggerHaptic(10);
                onCommand({ category: 'cam', action: 'filter', value: currentFilter === filterName ? 'normal' : filterName, target: activeCam?.id }); 
            };
            const canUseAI = activeCam?.hasAI || false;
            return (
                <div className="h-full flex flex-col">
                      <div className="flex-1 director-scroll p-4 space-y-4">
                        {!activeCam || (!activeCam.id && !isOffline) ? (
                            <div className="text-center text-neutral-600 py-10"><Aperture size={32} className="mx-auto mb-2 opacity-20" /><p className="text-[10px] font-mono uppercase tracking-widest leading-loose">Selecciona cámara<br/>en grid (Verde)</p></div>
                        ) : (
                            <>
                                <div className="pb-2 border-b border-neutral-800 mb-2">
                                    <h3 className="text-white font-bold text-sm flex items-center gap-2 uppercase tracking-tighter"><Settings size={14} className="text-red-500" /> CAM: {activeCam?.name || 'SIMULADOR'}</h3>
                                    <div className="text-[9px] text-gray-500 uppercase tracking-widest">{activeCam?.tally === 'preview' ? 'EN PREVIO' : 'AL AIRE'}</div>
                                </div>
                                <section>
                                    <label className="text-[10px] font-bold text-neutral-500 mb-2 block uppercase tracking-widest">Filtros Avanzados</label>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={() => handleFilterToggle('night')} className={`text-xs py-4 rounded-lg border flex flex-col items-center justify-center gap-2 font-bold ${currentFilter === 'night' ? 'bg-white text-black border-white' : 'bg-[#1a1a1a] text-green-500 border-green-900/30'}`}><Moon size={16}/> NOCTURNO</button>
                                        <button onClick={() => handleFilterToggle('thermal')} className={`text-xs py-4 rounded-lg border flex flex-col items-center justify-center gap-2 font-bold ${currentFilter === 'thermal' ? 'bg-white text-black border-white' : 'bg-[#1a1a1a] text-blue-500 border-blue-900/30'}`}><Flame size={16}/> TÉRMICO</button>
                                        <button onClick={() => handleFilterToggle('urbex')} className={`text-xs py-4 rounded-lg border flex flex-col items-center justify-center gap-2 font-bold ${currentFilter === 'urbex' ? 'bg-white text-black border-white' : 'bg-[#1a1a1a] text-orange-500 border-orange-900/30'}`}><Box size={16}/> URBEX</button>
                                        <button onClick={() => handleFilterToggle('lidar')} className={`text-xs py-4 rounded-lg border flex flex-col items-center justify-center gap-2 transition-colors font-bold ${currentFilter === 'lidar' ? 'bg-white text-black border-white shadow-[0_0_15px_rgba(255,255,255,0.5)]' : 'bg-[#1a1a1a] text-teal-400 border-teal-900/30'}`}><ScanLine size={16}/> LIDAR</button>
                                        <button onClick={() => handleFilterToggle('sls')} className={`text-xs py-4 rounded-lg border flex flex-col items-center justify-center gap-2 font-bold ${currentFilter === 'sls' ? 'bg-white text-black border-white' : 'bg-[#1a1a1a] text-purple-400 border-purple-900/30'}`}><Ghost size={16}/> SLS</button>
                                        <button onClick={() => { triggerHaptic(10); onCommand({ category: 'cmd', action: 'toggle', value: 'pareidolia', target: activeCam?.id }); }} disabled={!canUseAI} className={`text-xs py-4 rounded-lg border flex flex-col items-center justify-center gap-2 font-bold ${canUseAI ? (currentFilter === 'pareidolia' ? 'bg-white text-black border-white' : 'bg-red-900/20 hover:bg-red-600 text-red-500 hover:text-white border-red-900/50') : 'bg-[#151515] text-gray-600 border-gray-800 opacity-50 cursor-not-allowed'}`}><Eye size={16}/> {canUseAI ? 'VISION IA' : 'IA N/A'}</button>
                                        <button onClick={() => { triggerHaptic(10); onCommand({ category: 'cmd', action: 'reset', value: '', target: activeCam?.id }); }} className="col-span-2 mt-2 bg-neutral-900 hover:bg-neutral-800 text-gray-400 text-[10px] py-3 rounded-lg border border-neutral-800 flex items-center justify-center gap-2 uppercase font-bold tracking-widest"><RotateCcw size={12}/> Reset</button>
                                    </div>
                                </section>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        const formatTime = (seconds) => {
            if(!seconds || seconds <= 0) return "";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
        };

        const MediaPanel = ({ onPlay, timers, activeMedia, assetStatus }) => {
            const getButtonStyle = (type) => {
                const status = assetStatus?.[type] || 'loading';
                
                if (status !== 'ready') return 'bg-neutral-900 border-neutral-800 text-neutral-600 cursor-not-allowed opacity-50';
                
                if (type === 'intro') return activeMedia === 'intro' ? 'bg-cyan-600 text-white border-cyan-400' : 'bg-cyan-900/10 text-cyan-400 border-cyan-900/50 hover:bg-cyan-900/30';
                if (type === 'banner') return activeMedia === 'banner' ? 'bg-blue-600 text-white border-blue-400' : 'bg-blue-900/10 text-blue-400 border-blue-900/50 hover:bg-blue-900/30';
                if (type === 'outro') return activeMedia === 'outro' ? 'bg-red-600 text-white border-red-400' : 'bg-red-900/10 text-red-400 border-red-900/50 hover:bg-red-900/30';
                if (type.startsWith('backup')) return activeMedia === type ? 'bg-yellow-700 text-white border-yellow-500 animate-pulse' : 'bg-neutral-900 text-yellow-700 border-yellow-900/30';

                return 'bg-neutral-800 text-neutral-400 border-neutral-700 hover:text-white';
            };

            const isDisabled = (type) => {
                return (assetStatus?.[type] !== 'ready');
            }

            return (
                 <div className="p-3 border-t border-red-900/30 bg-[#080808] shrink-0 z-50 pb-safe shadow-[0_-5px_20px_rgba(0,0,0,0.8)]">
                     <h3 className="text-white font-bold text-[10px] flex items-center gap-2 mb-2 uppercase tracking-widest text-gray-500"><Film size={12} className="text-red-500" /> Media Control (Blob Only)</h3>
                     <div className="grid grid-cols-2 gap-2">
                        {['intro', 'standby', 'banner', 'outro'].map(key => (
                            <button key={key} disabled={isDisabled(key)} onClick={() => { triggerHaptic(15); onPlay(key); }} className={`relative text-xs py-3 rounded border flex items-center justify-center gap-1 overflow-hidden transition-colors font-bold ${getButtonStyle(key)}`}>
                                <span className="z-10 relative flex items-center gap-2 font-bold tracking-tighter uppercase">
                                    {(assetStatus?.[key] === 'loading' || !assetStatus?.[key]) ? <><Loader2 className="animate-spin" size={12}/> CARGANDO...</> : 
                                     assetStatus?.[key] === 'error' ? 'NO DISPONIBLE' :
                                     (key === 'standby' ? (activeMedia === 'standby' ? 'PAUSADO' : 'PAUSA') : 
                                     (timers && timers[key] > 0 ? formatTime(timers[key]) : key.toUpperCase()))}
                                </span>
                            </button>
                        ))}
                        {['backup1', 'backup2'].map(key => (
                            <button key={key} disabled={isDisabled(key)} onClick={() => { triggerHaptic(25); onPlay(key); }} className={`col-span-1 relative text-[10px] py-2 rounded border flex items-center justify-center gap-1 font-bold ${getButtonStyle(key)}`}>
                                <ShieldAlert size={10}/> {key.toUpperCase()}
                            </button>
                        ))}
                    </div>
                </div>
            );
        };
        
        const ObsCleanFeed = ({ targetId, blobAssets }) => {
            useWakeLock(true); // WAKE LOCK ACTIVADO
            const [stream, setStream] = useState(null);
            const [activeMedia, setActiveMedia] = useState(null);
            const peerRef = useRef(null);

            useEffect(() => {
                const peer = new window.Peer(null, PEER_CONFIG);
                peerRef.current = peer;

                peer.on('open', () => {
                    const conn = peer.connect(targetId, { reliable: true });
                    conn.on('open', () => { conn.send({ type: 'register-obs-client' }); });
                    conn.on('data', (data) => {
                        if(data.type === 'program-update') setActiveMedia(data.activeMedia);
                    });
                });

                peer.on('call', (call) => {
                    call.answer();
                    call.on('stream', (remoteStream) => setStream(remoteStream));
                });

                return () => peer.destroy();
            }, [targetId]);

            return (
                <div className="w-screen h-screen bg-black overflow-hidden relative flex items-center justify-center">
                    {stream ? (
                        // FIX: object-cover para maximizar calidad visual en OBS
                        <video ref={v => {if(v) v.srcObject = stream}} autoPlay playsInline className="w-full h-full object-cover" />
                    ) : (
                        <div className="text-neutral-800 font-bold text-2xl animate-pulse tracking-widest font-mono">ESPERANDO SEÑAL OBR...</div>
                    )}
                    <MediaOverlay activeMedia={activeMedia} blobAssets={blobAssets} onFinish={()=>{}} />
                </div>
            );
        };

        const RemoteDirector = ({ onBack }) => {
            useWakeLock(true); // WAKE LOCK ACTIVADO
            const [dockId, setDockId] = useState('');
            const [isConnected, setIsConnected] = useState(false);
            const [cameraList, setCameraList] = useState([]); 
            const [obsState, setObsState] = useState({ streaming: false, recording: false, connected: false });
            const [notifications, setNotifications] = useState([]);
            const [mediaTimers, setMediaTimers] = useState({ intro: 0, outro: 0, banner: 0, standby: 0 });
            const [activeMedia, setActiveMedia] = useState(null);
            const [peekStream, setPeekStream] = useState(null);
            const [peekName, setPeekName] = useState("");
            // --- NUEVO ESTADO AUDIO MIX ---
            const [forceCam1Audio, setForceCam1Audio] = useState(false);
            
            const [assetStatus, setAssetStatus] = useState({intro:'loading', outro:'loading', banner:'loading', standby:'loading', transicion:'loading', backup1: 'loading', backup2: 'loading'});
            
            const peerRef = useRef(null);
            const connRef = useRef(null);
            
            const activeProgramCam = cameraList.find(c => c.tally === 'program');
            const activePreviewCam = cameraList.find(c => c.tally === 'preview');
            const activeControlCam = activePreviewCam || activeProgramCam;
            
            const peekTimeoutRef = useRef(null);

            const notify = (msg, type = 'success') => {
                const id = Date.now();
                setNotifications(prev => [...prev, { id, msg, type }]);
                setTimeout(() => setNotifications(prev => prev.filter(n => n.id !== id)), 4000);
            };
            
            const enterSimulation = () => {
                 setAssetStatus({intro:'ready', outro:'ready', banner:'ready', standby:'ready', transicion:'ready', backup1: 'ready', backup2: 'ready'});
                 setCameraList([ { id: 'sim1', name: 'CAM SIM', tally: 'program', hasAI: true } ]);
                 setIsConnected(true);
            };
            
            // --- FIX: AUTO-CLOSE PEEK AFTER 2 SECONDS ---
            useEffect(() => {
                if (peekStream) {
                    const timer = setTimeout(() => {
                        setPeekStream(null);
                        send('peek', 'stop', null);
                    }, 2000);
                    return () => clearTimeout(timer);
                }
            }, [peekStream]);

            const connect = () => {
                if(!dockId) return;
                triggerHaptic(20);
                const peer = new window.Peer(null, { ...PEER_CONFIG });
                peerRef.current = peer;
                
                let targetId = dockId.trim();
                if (targetId.endsWith("-8889")) { targetId = targetId.slice(0, -5); }
                if (targetId.includes('.')) { targetId = targetId.replace(/\./g, '-'); }
                
                peer.on('open', (id) => {
                    const conn = peer.connect(targetId, { reliable: true });
                    connRef.current = conn;
                    conn.on('open', () => { setIsConnected(true); conn.send({ type: 'register-director' }); notify("CONEXIÓN CON ESTUDIO EXITOSA"); });
                    conn.on('data', (data) => {
                        if (data.type === 'camera-list-update') setCameraList(data.cameras);
                        if (data.type === 'obs-state-update') setObsState(data.state);
                        if (data.type === 'media-time') setMediaTimers(data.timers);
                        if (data.type === 'dock-status') { 
                            setActiveMedia(data.activeMedia); 
                            if (data.assetStatus) setAssetStatus(data.assetStatus);
                            if (typeof data.forceCam1Audio !== 'undefined') setForceCam1Audio(data.forceCam1Audio);
                        }
                        if (data.type === 'toast') notify(data.msg, data.toastType);
                    });
                    conn.on('close', () => { setIsConnected(false); notify("CONEXIÓN PERDIDA", "error"); });
                });
                
                peer.on('call', (call) => {
                    call.answer();
                    call.on('stream', (remoteStream) => { setPeekStream(remoteStream); });
                });
            };

            const send = (category, action, value) => {
                triggerHaptic(10);
                if(connRef.current) connRef.current.send({ type: 'director-cmd', category, action, value }); 
            };
            
            const handlePointerDown = (camId, camName) => {
                triggerHaptic(10);
                peekTimeoutRef.current = setTimeout(() => {
                    triggerHaptic(30); // Long press feedback
                    setPeekName(camName);
                    send('peek', 'start', camId);
                }, 600); 
            };

            const handlePointerUp = () => {
                if(peekTimeoutRef.current) clearTimeout(peekTimeoutRef.current);
            };
            
            const isTransicionReady = assetStatus['transicion'] === 'ready';

            if(!isConnected) {
                return (
                    <div className="min-h-screen bg-black flex flex-col items-center justify-center p-6 space-y-6">
                        <img src="./obr-logo.png" className="w-20 h-20 mb-4 drop-shadow-[0_0_15px_rgba(220,38,38,0.5)]" />
                        <h2 className="text-2xl font-bold text-white tracking-widest uppercase">Director <span className="text-red-600">Móvil</span></h2>
                        <input value={dockId} onChange={e=>setDockId(e.target.value)} placeholder="DOCK ID" className="w-full max-w-xs bg-[#111] border border-red-900 p-4 text-center text-xl text-white font-mono rounded-lg outline-none focus:border-red-500 mb-2 uppercase"/>
                        <button onClick={connect} className="w-full max-w-xs bg-red-900 text-white font-bold py-4 rounded-lg shadow-lg hover:bg-red-700 transition-colors uppercase tracking-widest">Conectar</button>
                        <button onClick={onBack} className="text-gray-500 text-sm mt-4 font-bold uppercase tracking-widest">Volver</button>
                        <button onClick={enterSimulation} className="text-[9px] text-gray-800 opacity-20 mt-10 uppercase font-bold tracking-[0.3em] tracking-widest uppercase">Modo Simulación</button>
                    </div>
                );
            }

            return (
                <div className="h-[100dvh] bg-black flex flex-col font-sans relative overflow-hidden" 
                     onPointerUp={handlePointerUp} onPointerLeave={handlePointerUp} onTouchEnd={handlePointerUp}>
                    
                    <ToastContainer notifications={notifications} />
                    {peekStream && <PeekModal stream={peekStream} name={peekName} onClose={()=>{setPeekStream(null); send('peek','stop',null);}} />}
                    
                    <div className="bg-[#111] p-3 border-b border-red-900 flex justify-between items-center shrink-0 z-20">
                        <div className="flex items-center gap-1 overflow-hidden">
                            <span className="font-bold text-xs tracking-tighter text-red-500 uppercase truncate">Director OBR</span>
                            <StatusIndicators isLive={obsState.streaming} isRec={obsState.recording} isObs={obsState.connected} />
                        </div>
                        <button onClick={() => { if(connRef.current) connRef.current.close(); setIsConnected(false); }} className="text-[9px] text-gray-500 px-2 py-1 rounded font-bold uppercase border border-neutral-800">Salir</button>
                    </div>

                    <div className="flex-1 director-scroll p-4 space-y-6 select-none bg-black">
                         <div className="space-y-2">
                            <h3 className="text-[9px] text-red-500 font-bold tracking-[0.3em] border-b border-red-900/40 pb-1 uppercase">Control de Emisión {obsState.connected ? '' : '(OBS OFFLINE)'}</h3>
                            <div className="grid grid-cols-2 gap-4">
                                <button 
                                    onClick={() => { triggerHaptic([30,30,30]); send('obs', 'start-stream', null); }} 
                                    disabled={!obsState.connected}
                                    className={`bg-green-700 border-b-4 border-green-900 text-white py-6 rounded-lg font-bold text-lg uppercase ${obsState.streaming ? 'opacity-50' : ''} ${!obsState.connected ? 'opacity-30 cursor-not-allowed' : ''}`}>
                                    Iniciar Live
                                </button>
                                <button 
                                    onClick={() => { triggerHaptic([50,50]); send('obs', 'stop-stream', null); }} 
                                    disabled={!obsState.connected}
                                    className={`bg-red-700 border-b-4 border-red-900 text-white py-6 rounded-lg font-bold text-lg uppercase ${!obsState.streaming ? 'opacity-50' : ''} ${!obsState.connected ? 'opacity-30 cursor-not-allowed' : ''}`}>
                                    Cortar Live
                                </button>
                            </div>
                            <div className="grid grid-cols-2 gap-4 mt-2">
                                <button 
                                    onClick={() => send('obs', 'start-record', null)} 
                                    disabled={!obsState.connected}
                                    className={`bg-yellow-700 border-b-4 border-yellow-900 text-white py-3 rounded-lg font-bold text-xs uppercase flex items-center justify-center gap-2 ${obsState.recording ? 'opacity-50' : ''} ${!obsState.connected ? 'opacity-30 cursor-not-allowed' : ''}`}>
                                    <Disc size={14}/> Grabar
                                </button>
                                <button 
                                    onClick={() => send('obs', 'stop-record', null)} 
                                    disabled={!obsState.connected}
                                    className={`bg-neutral-700 border-b-4 border-neutral-900 text-white py-3 rounded-lg font-bold text-xs uppercase flex items-center justify-center gap-2 ${!obsState.recording ? 'opacity-50' : ''} ${!obsState.connected ? 'opacity-30 cursor-not-allowed' : ''}`}>
                                    <X size={14}/> Parar Rec
                                </button>
                            </div>

                            <div className="grid grid-cols-2 gap-3 mt-4">
                                <button onClick={() => { triggerHaptic(20); send('mixer', 'cut', null); }} className="bg-neutral-800 border-b-4 border-neutral-900 text-white py-4 rounded-lg font-bold uppercase">Cut</button>
                                <button onClick={() => { triggerHaptic(20); send('mixer', 'auto', null); }} disabled={!isTransicionReady} className={`bg-gradient-to-r from-red-700 to-red-900 border-b-4 border-red-950 text-white py-4 rounded-lg font-bold uppercase ${!isTransicionReady ? 'opacity-50 grayscale cursor-not-allowed' : ''}`}>{isTransicionReady ? 'Auto Mix' : 'No Trans.'}</button>
                            </div>

                            <button onClick={() => send('mixer', 'toggle-audio-mix', null)} className={`w-full mt-4 text-[10px] py-3 rounded border-b-4 flex items-center justify-center gap-2 transition-colors font-bold uppercase tracking-widest ${forceCam1Audio ? 'bg-blue-900 border-blue-950 text-white' : 'bg-neutral-800 border-neutral-900 text-gray-400'}`}>
                                <Music size={14}/> {forceCam1Audio ? 'AUDIO: SOLO CAM 1' : 'AUDIO: AUTO MIX'}
                            </button>
                        </div>
                        
                        <div className="space-y-2">
                             <h3 className="text-[9px] text-gray-500 font-bold tracking-[0.3em] border-b border-gray-800 pb-1 flex justify-between uppercase">
                                <span>Fuentes en Grid</span>
                                <span className="text-[8px] text-yellow-600 lowercase tracking-tighter tracking-widest uppercase">Long-press Peek</span>
                            </h3>
                             {cameraList.map(cam => (
                                <div key={cam.id} 
                                    className={`flex items-center border rounded-lg p-2 gap-3 transition-all active:scale-[0.98] ${cam.tally === 'program' ? 'bg-red-900/20 border-red-600 shadow-[0_0_15px_rgba(220,38,38,0.2)]' : cam.tally === 'preview' ? 'preview-selected border-green-600' : 'bg-[#151515] border-gray-800'}`} 
                                    onPointerDown={() => handlePointerDown(cam.id, cam.name)}
                                    onClick={()=>{ send('mixer', 'preview', cam.id) }}>
                                    
                                    <div className="w-14 aspect-video bg-black rounded border border-neutral-800 flex items-center justify-center overflow-hidden shrink-0 pointer-events-none relative">
                                        {cam.snapshot ? <img src={cam.snapshot} className="w-full h-full object-cover opacity-80" /> : <Monitor size={12} className="opacity-20 text-white"/>}
                                    </div>

                                    <div className="flex-1 flex flex-col justify-center pointer-events-none overflow-hidden">
                                        <div className="text-white font-mono text-[11px] font-bold uppercase tracking-widest truncate">{cam.name}</div>
                                        <div className="flex gap-2 text-[8px] text-gray-500 font-mono tracking-widest uppercase tracking-tighter">
                                            <span className={`flex items-center gap-1 font-bold ${cam.tally === 'program' ? 'text-red-500' : cam.tally === 'preview' ? 'text-green-500' : ''}`}>
                                                {cam.tally === 'program' ? 'Al Aire' : cam.tally === 'preview' ? 'En Previo' : 'Lista'}
                                            </span>
                                        </div>
                                    </div>

                                    <div className="flex gap-1">
                                        <button onClick={(e) => { e.stopPropagation(); triggerHaptic(20); send('mixer', 'auto', cam.id); }} className="px-2 py-3 bg-red-800 hover:bg-red-600 text-white rounded text-[8px] font-bold uppercase border border-red-900 transition-colors uppercase tracking-widest">Auto</button>
                                        <button onClick={(e)=>{e.stopPropagation(); triggerHaptic(20); send('mixer','program',cam.id)}} className="px-3 py-2 bg-red-800 text-white rounded text-[9px] font-bold">CUT</button>
                                    </div>
                                </div>
                             ))}
                        </div>
                        <DirectorPanel activeCam={activeControlCam} onCommand={send} isOffline={false} currentFilter={activeControlCam?.filter || 'normal'} />
                    </div>
                    <MediaPanel onPlay={(type) => send('media', 'play', type)} timers={mediaTimers} activeMedia={activeMedia} assetStatus={assetStatus} />
                </div>
            );
        };

        const DockMode = ({ preferredId, initialBlobAssets }) => {
          useWakeLock(true); // WAKE LOCK ACTIVADO
          const [myId, setMyId] = useState(null);
          const [cameras, setCameras] = useState({}); 
          const [programId, setProgramId] = useState(null);
          const [previewId, setPreviewId] = useState(null);
          const [activeMedia, setActiveMedia] = useState(null);
          const [headerHidden, setHeaderHidden] = useState(false);
          const [notifications, setNotifications] = useState([]);
          const [mediaTimers, setMediaTimers] = useState({ intro: 0, outro: 0, banner: 0, standby: 0 }); 
          const [isShareModalOpen, setIsShareModalOpen] = useState(false);
          const [obsStreaming, setObsStreaming] = useState(false);
          const [obsRecording, setObsRecording] = useState(false);
          const [obsConnected, setObsConnected] = useState(false);
          const [zoomedCamId, setZoomedCamId] = useState(null);
          const [backupIndex, setBackupIndex] = useState(0);
          
          const [forceCam1Audio, setForceCam1Audio] = useState(false);
          
          const [blobAssets, setBlobAssets] = useState(initialBlobAssets || {}); 
          const [assetStatus, setAssetStatus] = useState(() => {
              const status = {};
              ['intro', 'outro', 'banner', 'standby', 'transicion', 'backup1', 'backup2'].forEach(k => {
                  status[k] = initialBlobAssets && initialBlobAssets[k] ? 'ready' : 'error';
              });
              return status;
          });

          const camerasRef = useRef({});
          const activeMediaRef = useRef(null);
          const assetStatusRef = useRef({});
          const obsStateRef = useRef({ streaming: false, recording: false, connected: false });
          const forceCam1AudioRef = useRef(false);
          
          const directorConnRef = useRef(null);
          const obsClientsRef = useRef([]);

          const obsRef = useRef(null); 
          const peerRef = useRef(null);
          const videoPeerRef = useRef(null);
          
          const previewRef = useRef(null);
          const programRef = useRef(null);

          useEffect(() => { camerasRef.current = cameras; }, [cameras]);
          useEffect(() => { activeMediaRef.current = activeMedia; }, [activeMedia]);
          useEffect(() => { assetStatusRef.current = assetStatus; }, [assetStatus]);
          useEffect(() => { obsStateRef.current = { streaming: obsStreaming, recording: obsRecording, connected: obsConnected }; }, [obsStreaming, obsRecording, obsConnected]);
          useEffect(() => { previewRef.current = previewId; }, [previewId]);
          useEffect(() => { programRef.current = programId; }, [programId]);
          useEffect(() => { forceCam1AudioRef.current = forceCam1Audio; }, [forceCam1Audio]);

          const notify = (msg, type = 'success') => { 
              const id = Date.now(); 
              setNotifications(prev => [...prev, { id, msg, type }]); 
              setTimeout(() => setNotifications(prev => prev.filter(n => n.id !== id)), 4000); 
              if (directorConnRef.current?.open) directorConnRef.current.send({ type: 'toast', msg, toastType: type });
          };
          
          const handleTimeUpdate = (duration, currentTime) => {
              const remaining = duration - currentTime;
              const newTimers = { 
                  intro: activeMedia === 'intro' ? remaining : 0, 
                  outro: activeMedia === 'outro' ? remaining : 0, 
                  banner: activeMedia === 'banner' ? remaining : 0, 
                  standby: activeMedia === 'standby' ? 1 : 0 
              };
              setMediaTimers(newTimers);
              if (directorConnRef.current?.open && activeMedia) { 
                  directorConnRef.current.send({ type: 'media-time', timers: newTimers }); 
              }
          };

          // --- SURGICAL REPLACEMENT: NATIVE OBS WEBSOCKET (NO LIBRARY) ---
          useEffect(() => {
              let ws;
              let reconnectTimer;
              
              const connect = () => {
                  try {
                      ws = new WebSocket('ws://localhost:4455');
                      obsRef.current = ws;

                      ws.onopen = () => {
                          setObsConnected(true);
                          // IDENTIFY OP: 1 (NECESARIO PARA OBS V5)
                          ws.send(JSON.stringify({ op: 1, d: { rpcVersion: 1 } }));
                          
                          // FIX: REQUEST INITIAL STATUS TO ENSURE GREEN LIGHTS IF ALREADY STREAMING
                          setTimeout(() => {
                              if(ws.readyState === 1) {
                                  ws.send(JSON.stringify({ op: 6, d: { requestType: 'GetStreamStatus', requestId: 'init-stream' } }));
                                  ws.send(JSON.stringify({ op: 6, d: { requestType: 'GetRecordStatus', requestId: 'init-rec' } }));
                              }
                          }, 500);
                      };

                      ws.onmessage = (event) => {
                          const msg = JSON.parse(event.data);
                          // EVENTS OP: 5
                          if (msg.op === 5) {
                              const type = msg.d.eventType;
                              if (type === 'StreamStateChanged') setObsStreaming(msg.d.eventData.outputActive);
                              if (type === 'RecordStateChanged') setObsRecording(msg.d.eventData.outputActive);
                          }
                          // REQUEST RESPONSE OP: 7
                          if (msg.op === 7) {
                              if(msg.d.requestType === 'GetStreamStatus') setObsStreaming(msg.d.responseData.outputActive);
                              if(msg.d.requestType === 'GetRecordStatus') setObsRecording(msg.d.responseData.outputActive);
                          }
                      };

                      ws.onclose = () => {
                          setObsConnected(false);
                          setObsStreaming(false);
                          setObsRecording(false);
                          reconnectTimer = setTimeout(connect, 3000); 
                      };
                  } catch (e) { console.error(e); }
              };
              connect();
              return () => { if(ws) ws.close(); clearTimeout(reconnectTimer); };
          }, []);

          const sendToOBS = (action) => {
             triggerHaptic(20);
             if (!obsRef.current || obsRef.current.readyState !== 1) return;
             
             // MAPPING SIMPLE COMMANDS TO OBS V5 REQUESTS
             let reqType = "";
             if (action === 'start-stream') reqType = "StartStream";
             if (action === 'stop-stream') reqType = "StopStream";
             if (action === 'start-record') reqType = "StartRecord";
             if (action === 'stop-record') reqType = "StopRecord";
             
             if (reqType) {
                 const reqId = Math.random().toString(36).substring(7);
                 obsRef.current.send(JSON.stringify({
                     op: 6, // REQUEST OP
                     d: { requestType: reqType, requestId: reqId }
                 }));
             }
          };
          // --- END SURGICAL REPLACEMENT ---
          
          // --- FIX: HELPER TO SEND CAMERA LIST ---
          // --- NOW USING REFS TO ENSURE DYNAMIC TALLY & FILTER UPDATES ---
          const getSerializableCameras = () => {
             return Object.values(camerasRef.current).map(c => ({
                 id: c.id, 
                 name: c.name, 
                 // DYNAMIC TALLY CALCULATION BASED ON REFS
                 tally: (c.id === programRef.current) ? 'program' : (c.id === previewRef.current ? 'preview' : 'idle'), 
                 hasAI: c.hasAI, 
                 snapshot: c.snapshot,
                 filter: c.filter || 'normal' // SYNC FILTER STATE
             }));
          };

          useEffect(() => {
            let baseId = preferredId;
            if (baseId?.endsWith("-8889")) baseId = baseId.slice(0, -5);
            baseId = baseId ? baseId.replace(/\./g, '-') : null;
            if (!baseId) return;

            const peerCmd = new window.Peer(baseId, PEER_CONFIG);
            peerRef.current = peerCmd;

            peerCmd.on('open', (id) => setMyId(id));
            
            // --- FIX: RESTORED VIDEO CALL LISTENER ON MAIN CHANNEL (BACKUP) ---
            peerCmd.on('call', (call) => {
                call.answer();
                call.on('stream', (stream) => {
                    const name = call.metadata?.name || call.peer;
                    setCameras(prev => ({ ...prev, [name]: { ...(prev[name] || {}), stream } }));
                });
            });
            // -----------------------------------------------------------------

            peerCmd.on('connection', (conn) => {
                conn.on('data', (data) => {
                    if (data.type === 'register') { 
                        setCameras(prev => ({ ...prev, [data.name]: { id: data.name, conn, name: data.name, tally: 'idle', hasAI: data.hasAI } })); 
                        notify(`CAMARA: ${data.name}`); 
                    }
                    if (data.type === 'register-director') { 
                        directorConnRef.current = conn; 
                        notify("DIRECTOR CONECTADO");
                        // FIX: SEND STATE IMMEDIATELY ON CONNECT
                        conn.send({ type: 'obs-state-update', state: obsStateRef.current });
                        // FIX: SEND CAMERAS IMMEDIATELY
                        conn.send({ type: 'camera-list-update', cameras: getSerializableCameras() });
                    }
                    if (data.type === 'register-obs-client') { 
                        obsClientsRef.current.push(conn.peer);
                        conn.send({ type: 'program-update', activeMedia: activeMediaRef.current });
                    }
                    if (data.type === 'director-cmd') handleDirectorCommand(data);
                });
                conn.on('error', (err) => console.error("Conn Error", err));
            });
            peerCmd.on('error', (err) => { 
                console.error("Peer Error", err);
                if(err.type === 'disconnected') peerCmd.reconnect();
            });

            const videoId = baseId + "-8889";
            const peerVid = new window.Peer(videoId, PEER_CONFIG);
            videoPeerRef.current = peerVid;
            
            peerVid.on('call', (call) => { 
                call.answer(); 
                call.on('stream', (stream) => { 
                    const name = call.metadata?.name || call.peer; 
                    setCameras(prev => ({ ...prev, [name]: { ...(prev[name] || {}), stream } })); 
                }); 
            });

            const statusInterval = setInterval(() => {
                 if (directorConnRef.current?.open) {
                     directorConnRef.current.send({ 
                         type: 'dock-status', 
                         activeMedia: activeMediaRef.current, 
                         assetStatus: assetStatusRef.current,
                         forceCam1Audio: forceCam1AudioRef.current
                     });
                     directorConnRef.current.send({ type: 'obs-state-update', state: obsStateRef.current });
                     // FIX: SEND CAMERA LIST PERIODICALLY
                     directorConnRef.current.send({ type: 'camera-list-update', cameras: getSerializableCameras() });
                 }
                 Object.values(camerasRef.current).forEach(cam => {
                     if(cam.conn && cam.conn.open) {
                         cam.conn.send({ type: 'ping' });
                     }
                 });
            }, 1000);

            return () => { 
                peerCmd.destroy(); 
                peerVid.destroy(); 
                clearInterval(statusInterval); 
            };
          }, []); 

          useEffect(() => {
              if (programId && !activeMedia) {
                  const currentCam = cameras[programId];
                  const isSignalLost = !currentCam || !currentCam.stream || !currentCam.stream.active;
                  if (isSignalLost) {
                      notify("⚠️ SEÑAL PERDIDA: INICIANDO FAILOVER", "error");
                      handleFailover();
                  }
              }
          }, [programId, cameras, activeMedia]);

          const handleFailover = () => {
              triggerHaptic([50, 50, 50]);
              const transReady = assetStatus['transicion'] === 'ready';
              if(transReady) {
                  setActiveMedia('transicion');
                  setHeaderHidden(true);
                  setTimeout(() => { playNextBackup(); }, 1200);
              } else {
                  playNextBackup();
              }
          };

          const playNextBackup = () => {
              const backups = ['backup1', 'backup2'];
              let nextIdx = backupIndex;
              let found = false;
              let attempts = 0;
              while(attempts < 2) {
                  const key = backups[nextIdx];
                  if (assetStatus[key] === 'ready') {
                      setActiveMedia(key);
                      setBackupIndex((nextIdx + 1) % 2);
                      notify(`REPRODUCIENDO RESPALDO: ${key.toUpperCase()}`, "warning");
                      found = true;
                      break;
                  }
                  nextIdx = (nextIdx + 1) % 2;
                  attempts++;
              }
              if (!found) {
                  notify("⚠️ NO HAY VIDEOS DE RESPALDO DISPONIBLES", "error");
                  setActiveMedia('standby');
              }
          };

          useEffect(() => {
              if (programId && cameras[programId]?.stream && videoPeerRef.current) {
                  obsClientsRef.current.forEach(clientId => {
                      try { videoPeerRef.current.call(clientId, cameras[programId].stream); } catch(e){}
                  });
              }
              if(peerRef.current) {
                  Object.values(peerRef.current.connections).forEach(conns => conns.forEach(c => {
                      if(c.open) c.send({ type: 'program-update', activeMedia });
                  }));
              }
          }, [programId, activeMedia, cameras]);

          const handleDirectorCommand = (cmd) => {
              if (cmd.category === 'cam') {
                  const targetCamId = cmd.target; 
                  if (targetCamId && camerasRef.current[targetCamId]?.conn) {
                      camerasRef.current[targetCamId].conn.send({ type: 'cmd', action: cmd.action, value: cmd.value });
                      if(cmd.action === 'filter') {
                          setCameras(prev => ({...prev, [targetCamId]: {...prev[targetCamId], filter: cmd.value}}));
                          notify(`FILTRO ACTIVADO: ${cmd.value.toUpperCase()}`);
                      }
                  } else {
                      notify("Error: Cámara no encontrada", "error");
                  }
              }

              if (cmd.category === 'media') handlePlayLocal(cmd.value);
              if (cmd.category === 'mixer') {
                    if(cmd.action === 'cut') switchProgram(previewId);
                    if(cmd.action === 'auto') handleAuto();
                    if(cmd.action === 'preview') setPreviewId(cmd.value);
                    if(cmd.action === 'program') switchProgram(cmd.value);
                    if(cmd.action === 'toggle-audio-mix') setForceCam1Audio(prev => !prev);
              }
              if (cmd.category === 'obs') sendToOBS(cmd.action);
          };

          const switchProgram = (id) => { 
              triggerHaptic(25);
              setProgramId(id); setPreviewId(null); setActiveMedia(null); setHeaderHidden(false); 
              Object.values(cameras).forEach(c => {
                  if(c.conn) c.conn.send({ type: 'tally', state: c.id === id ? 'program' : 'idle' });
              });
          };
          
          const handleAuto = () => {
              triggerHaptic(20);
              if(assetStatus['transicion'] !== 'ready') {
                  notify("TRANSICIÓN NO DISPONIBLE", "error");
                  return;
              }
              handlePlayLocal('transicion');
          };
          
          const handlePlayLocal = (type) => { 
              if(assetStatus[type] !== 'ready') return;
              if(activeMedia === type && type === 'banner') { setActiveMedia(null); return; } 
              setActiveMedia(type); 
              if(type === 'intro' || type === 'transicion') setHeaderHidden(true);
          };
          
          const handleMediaFinish = () => {
              if (activeMedia === 'outro') { sendToOBS('stop-stream'); sendToOBS('stop-record'); }
              
              if (activeMedia === 'transicion') {
                    if(previewRef.current) switchProgram(previewRef.current);
                    else { setActiveMedia(null); setHeaderHidden(false); }
                    return;
              }

              if (activeMedia && activeMedia.startsWith('backup')) {
                  const cam = cameras[programId];
                  if (cam && cam.stream && cam.stream.active) {
                      notify("SEÑAL RECUPERADA - VOLVIENDO AL AIRE", "success");
                      setActiveMedia(null); 
                  } else {
                      notify("SEÑAL AÚN PERDIDA - ROTANDO BACKUP", "warning");
                      handleFailover(); 
                      return;
                  }
              }
              setActiveMedia(null); setHeaderHidden(false);
          };

          const generateObsLink = () => {
              const url = `${window.location.href.split('?')[0]}?mode=obs-clean&target=${myId}`;
              navigator.clipboard.writeText(url);
              notify("LINK OBS COPIADO");
              alert("ENLACE LOCAL GENERADO:\n\n1. Ve a OBS en esta PC.\n2. Agrega 'Navegador'.\n3. Pega el enlace.\n\n" + url);
          };

          const previewCam = previewId ? cameras[previewId] : null;
          const camList = Object.values(cameras);
          const isTransicionReady = assetStatus['transicion'] === 'ready';
          const isFailoverMode = activeMedia && activeMedia.startsWith('backup');
          
          const cam1Id = camList.length > 0 ? camList[0].id : null;
          const isProgramMuted = forceCam1Audio ? (programId !== cam1Id) : false;

          const activeCamForPanel = previewCam || cameras[programId];

          return (
            <div className={`h-screen flex flex-col bg-[#0a0a0a] text-neutral-300 font-sans overflow-hidden select-none ${isFailoverMode ? 'emergency-mode' : ''}`}>
                <ToastContainer notifications={notifications} />
                {isShareModalOpen && <ShareModal onClose={() => setIsShareModalOpen(false)} dockId={myId} />}
                {zoomedCamId && cameras[zoomedCamId] && <ZoomModal stream={cameras[zoomedCamId].stream} name={cameras[zoomedCamId].name} onClose={() => setZoomedCamId(null)} />}
                
                <div className="h-12 bg-black border-b border-[#222] flex items-center justify-center relative shrink-0">
                    <div className="absolute left-4 flex items-center">
                        <img src="./obr-logo.png" className="w-6 h-6 object-contain mr-3" />
                        <span className="font-bold text-white tracking-widest text-[10px] uppercase hidden sm:block">Exploraciones OBR | Studio v6.1.2 PRO</span>
                        <StatusIndicators isLive={obsStreaming} isRec={obsRecording} isObs={obsConnected} isFailover={isFailoverMode} />
                    </div>
                    
                    <div className="flex items-center gap-4">
                        <button 
                            onClick={() => sendToOBS(obsStreaming ? 'stop-stream' : 'start-stream')} 
                            disabled={!obsConnected}
                            className={`px-4 py-1 rounded text-[10px] font-bold uppercase transition-all ${obsStreaming ? 'bg-red-600 text-white animate-pulse' : 'bg-neutral-800 text-neutral-400 hover:text-white'} ${!obsConnected ? 'opacity-30 cursor-not-allowed' : ''}`}>
                            {obsStreaming ? 'STOP LIVE' : 'GO LIVE'}
                        </button>
                        <button 
                            onClick={() => sendToOBS(obsRecording ? 'stop-record' : 'start-record')} 
                            disabled={!obsConnected}
                            className={`px-4 py-1 rounded text-[10px] font-bold uppercase transition-all ${obsRecording ? 'bg-white text-black' : 'bg-neutral-800 text-neutral-400 hover:text-white'} ${!obsConnected ? 'opacity-30 cursor-not-allowed' : ''}`}>
                            {obsRecording ? 'STOP REC' : 'REC'}
                        </button>
                    </div>

                    <div className="absolute right-4 flex items-center gap-4">
                        <div className="font-mono text-cyan-400 text-[10px] bg-[#111] px-2 py-1 border border-[#333] rounded cursor-pointer uppercase tracking-widest" onClick={() => { navigator.clipboard.writeText(myId); notify("Copiado"); }}>ID: {myId || '---'}</div>
                        <button onClick={generateObsLink} className="text-[10px] bg-blue-900/30 text-blue-200 border border-blue-800 px-3 py-1 rounded font-bold uppercase flex items-center gap-1 shadow-lg active:scale-95 transition-all"><Link size={12}/> Link Local OBS</button>
                    </div>
                </div>

                <div className="flex-1 flex overflow-hidden">
                    <div className="flex-1 flex flex-col p-4 gap-4 overflow-hidden">
                        <div className="h-[55%] flex gap-4">
                            <div className="flex-1 bg-black rounded-xl border border-neutral-800 relative overflow-hidden shadow-2xl">
                                <div className="absolute top-3 left-3 bg-green-600 text-[9px] px-2 py-1 rounded font-bold uppercase z-10 shadow-lg tracking-widest">Preview</div>
                                {previewCam?.stream ? ( <VideoPeer stream={previewCam.stream} className="w-full h-full object-contain" /> ) : ( <div className="w-full h-full flex items-center justify-center opacity-10"><Monitor size={48} /></div> )}
                            </div>
                            <div className="flex-1 bg-black rounded-xl border-2 border-red-900/40 relative overflow-hidden shadow-2xl">
                                 <div className="absolute top-3 left-3 bg-red-600 text-[9px] px-2 py-1 rounded font-bold uppercase z-10 shadow-lg tracking-widest">Program</div>
                                 <div className="relative w-full h-full bg-[#050505]">
                                    <VideoPeer stream={cameras[programId]?.stream} className="w-full h-full object-cover" muted={isProgramMuted} />
                                    <MediaOverlay activeMedia={activeMedia} blobAssets={blobAssets} onFinish={handleMediaFinish} onTimeUpdate={handleTimeUpdate} />
                                 </div>
                            </div>
                        </div>
                        <div className="h-16 bg-[#111] rounded-xl border border-neutral-800 flex items-center justify-center gap-8 shadow-inner border-t-2 border-neutral-900/50">
                             <button onClick={() => { triggerHaptic(25); previewId && switchProgram(previewId); }} className="h-10 px-10 bg-neutral-700 hover:bg-neutral-600 text-white font-bold rounded uppercase text-[10px] active:translate-y-0.5 shadow-md border-b-2 border-neutral-900 tracking-widest">Cut</button>
                             <button onClick={handleAuto} disabled={!isTransicionReady} className={`h-12 px-16 bg-red-800 hover:bg-red-700 text-white font-bold rounded uppercase text-xs active:translate-y-0.5 shadow-xl border-b-4 border-red-950 tracking-[0.3em] ${!isTransicionReady ? 'opacity-50 grayscale cursor-not-allowed' : ''}`}>{isTransicionReady ? 'Auto Mix' : 'No Trans.'}</button>
                             <button onClick={() => handlePlayLocal('standby')} disabled={assetStatus['standby'] !== 'ready'} className={`h-10 px-6 bg-black border border-neutral-800 text-neutral-500 hover:text-white rounded text-[10px] uppercase font-bold tracking-widest transition-colors ${activeMedia === 'standby' ? 'border-yellow-600 text-yellow-500' : ''} ${assetStatus['standby'] !== 'ready' ? 'opacity-50 cursor-not-allowed' : ''}`}>Pausar</button>
                        </div>
                        <div className="flex-1 bg-[#080808] rounded-xl p-3 border border-neutral-800 overflow-y-auto">
                            <div className="grid grid-cols-4 lg:grid-cols-5 gap-3 content-start">
                                {camList.map(cam => (
                                    <div key={cam.id} 
                                        onClick={() => { triggerHaptic(10); setPreviewId(cam.id); }}
                                        className={`aspect-video bg-black rounded-lg border-2 cursor-pointer relative overflow-hidden transition-all group ${cam.tally === 'program' ? 'border-red-600 shadow-[0_0_15px_rgba(220,38,38,0.4)]' : cam.tally === 'preview' ? 'preview-selected border-green-600' : 'border-neutral-800 hover:border-neutral-600'}`}>
                                        {cam.stream && <VideoPeer stream={cam.stream} className="w-full h-full object-cover opacity-60 pointer-events-none" />}
                                        <div className="absolute bottom-0 left-0 right-0 bg-black/80 px-2 py-1 text-[9px] font-bold uppercase tracking-tighter truncate">{cam.name}</div>
                                    </div>
                                ))}
                                {camList.length === 0 && <div className="col-span-full py-10 text-center text-neutral-800 text-[10px] font-bold uppercase tracking-[0.5em] opacity-30">Sin cámaras activas</div>}
                            </div>
                        </div>
                    </div>
                    <div className="w-64 bg-[#111] border-l border-neutral-800 flex flex-col shrink-0 shadow-2xl">
                        <div className="p-4 border-b border-neutral-800 space-y-3">
                            <button onClick={() => setIsShareModalOpen(true)} className="w-full bg-green-900/20 text-green-500 text-[10px] py-2 rounded border border-green-800 uppercase font-bold hover:bg-green-900/40 transition-colors tracking-widest">Compartir Acceso</button>
                            <button onClick={() => { triggerHaptic(10); setForceCam1Audio(!forceCam1Audio); }} className={`w-full text-[10px] py-2 rounded border flex items-center justify-center gap-2 transition-colors font-bold uppercase tracking-widest ${forceCam1Audio ? 'bg-blue-900 text-white border-blue-500' : 'bg-neutral-800 text-gray-400 border-neutral-700'}`}><Music size={14}/> {forceCam1Audio ? 'AUDIO: SOLO CAM 1' : 'AUDIO: AUTO MIX'}</button>
                        </div>
                        <MediaPanel onPlay={handlePlayLocal} timers={mediaTimers} activeMedia={activeMedia} assetStatus={assetStatus} />
                        <DirectorPanel activeCam={activeCamForPanel} onCommand={handleDirectorCommand} isOffline={false} currentFilter={activeCamForPanel?.filter || 'normal'} />
                    </div>
                </div>
            </div>
          );
        };

        const AssetLoader = ({ onReady }) => {
            const [status, setStatus] = useState({});
            const [progress, setProgress] = useState(0);

            useEffect(() => {
                const loadAll = async () => {
                    const loadedBlobs = {};
                    const keys = Object.keys(STUDIO_ASSETS);
                    let loadedCount = 0;

                    for (const key of keys) {
                        try {
                            setStatus(prev => ({...prev, [key]: 'loading'}));
                            const response = await fetch(STUDIO_ASSETS[key]);
                            if (!response.ok) throw new Error('Error');
                            const blob = await response.blob();
                            loadedBlobs[key] = URL.createObjectURL(blob);
                            setStatus(prev => ({...prev, [key]: 'ready'}));
                        } catch (e) {
                            console.error(e);
                            setStatus(prev => ({...prev, [key]: 'error'}));
                        }
                        loadedCount++;
                        setProgress(Math.round((loadedCount / keys.length) * 100));
                    }
                    setTimeout(() => onReady(loadedBlobs), 800);
                };
                loadAll();
            }, []);

            return (
                <div className="h-screen w-screen bg-black flex flex-col items-center justify-center text-white font-mono z-[9999]">
                    <img src="./obr-logo.png" className="w-20 h-20 mb-6 animate-pulse drop-shadow-[0_0_15px_rgba(220,38,38,0.5)]" />
                    <div className="text-xs tracking-[0.5em] text-red-500 mb-2 font-bold uppercase">Descargando Medios...</div>
                    <div className="w-64 h-1 bg-neutral-900 rounded overflow-hidden mb-6 border border-neutral-800">
                        <div className="h-full bg-red-600 transition-all duration-300" style={{width: `${progress}%`}}></div>
                    </div>
                    <div className="text-[9px] text-neutral-500 flex flex-col gap-1 items-start min-w-[200px]">
                        {Object.keys(STUDIO_ASSETS).map(k => (
                            <div key={k} className="flex justify-between w-full uppercase tracking-widest">
                                <span className="opacity-50">{k}</span>
                                <span className={status[k] === 'ready' ? 'text-green-500 font-bold' : 'text-neutral-600'}>
                                    {status[k] === 'ready' ? 'OK' : status[k] === 'error' ? 'ERR' : '...'}
                                </span>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const Lobby = ({ onCreate, onRemote }) => {
          const [customId, setCustomId] = useState("");
          return (
            <div className="min-h-screen bg-black text-white flex flex-col items-center justify-center p-6 relative overflow-hidden">
              <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-neutral-900 via-black to-black opacity-60"></div>
              <div className="relative z-10 w-full max-w-sm bg-[#111] p-8 rounded-2xl border border-[#222] shadow-2xl flex flex-col gap-6 animate-fade-in">
                <div className="text-center">
                    <img src="./obr-logo.png" className="w-24 h-24 mx-auto mb-4 object-contain drop-shadow-[0_0_20px_rgba(220,38,38,0.6)]" />
                    <h1 className="text-2xl font-bold text-white tracking-widest uppercase">Estudio <span className="text-red-600">OBR</span></h1>
                    <p className="text-gray-500 text-[10px] mt-1 uppercase tracking-[0.4em] opacity-50 font-bold">v6.1.2 PRO</p>
                </div>
                <div className="bg-black/50 p-4 rounded border border-gray-800">
                    <label className="text-[10px] text-gray-500 font-bold mb-1 block uppercase tracking-widest">ID (Tailscale IP)</label>
                    <input value={customId} onChange={e => setCustomId(e.target.value)} placeholder="Ej: 100.80.20.14" className="w-full bg-transparent text-white font-mono text-center outline-none border-b border-gray-700 focus:border-red-500 text-sm py-1 uppercase font-bold tracking-widest"/>
                </div>
                <button onClick={() => onCreate(customId)} className="w-full bg-white text-black font-bold py-4 rounded-xl flex items-center justify-center gap-3 hover:scale-[1.02] transition-all uppercase tracking-widest"><Monitor size={20} /> Crear Estudio</button>
                <div className="h-px bg-[#333] w-full"></div>
                <button onClick={onRemote} className="w-full bg-[#222] text-gray-300 font-bold py-4 rounded-xl flex items-center justify-center gap-3 border border-[#333] hover:bg-[#333] hover:text-white transition-all uppercase tracking-widest"><Smartphone size={20} /> Conectar Director</button>
              </div>
            </div>
          );
        };

        const App = () => {
          const loaded = usePeerJS();
          const [mode, setMode] = useState('lobby');
          const [id, setId] = useState("");
          const [assets, setAssets] = useState(null);
          
          useEffect(() => {
              const params = new URLSearchParams(window.location.search);
              if (params.get('mode') === 'obs-clean' && params.get('target')) {
                  setId(params.get('target'));
                  setMode('loading-assets-obs');
              }
          }, []);

          const handleAssetsReady = (loadedBlobs) => {
              setAssets(loadedBlobs);
              if (mode === 'loading-assets-obs') setMode('obs-clean');
              else setMode('dock');
          };

          if(!loaded) return <div className="h-screen w-screen bg-black flex items-center justify-center"><div className="text-red-600 animate-pulse font-bold text-xs tracking-[0.5em] uppercase">Cargando Sistema...</div></div>;

          return (
            <>
              {mode === 'lobby' && <Lobby onCreate={(val) => { setId(val); setMode('loading-assets-dock'); }} onRemote={() => setMode('remote-director')} />}
              {(mode === 'loading-assets-dock' || mode === 'loading-assets-obs') && <AssetLoader onReady={handleAssetsReady} />}
              {mode === 'dock' && <DockMode preferredId={id} initialBlobAssets={assets} />}
              {mode === 'obs-clean' && <ObsCleanFeed targetId={id} blobAssets={assets} />}
              {mode === 'remote-director' && <RemoteDirector onBack={() => setMode('lobby')} />}
            </>
          );
        };

        createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
